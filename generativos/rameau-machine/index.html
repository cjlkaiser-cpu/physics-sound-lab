<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rameau Machine - Armonia Funcional Generativa</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap');

        * { box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: #0a0a0f;
            color: #e2e8f0;
            margin: 0;
            overflow: hidden;
        }

        .function-zone {
            pointer-events: none;
        }

        .chord-node {
            cursor: pointer;
        }

        /* Hover effect solo en el cÃ­rculo visual, no desplaza el grupo */
        .chord-node:hover .node-visual {
            filter: brightness(1.3);
            transition: filter 0.15s ease;
        }

        .chord-node.active {
            filter: drop-shadow(0 0 20px currentColor);
        }

        .transition-arc {
            fill: none;
            pointer-events: none;
        }

        .trail-line {
            fill: none;
            stroke-linecap: round;
        }

        .control-panel {
            background: rgba(15, 23, 42, 0.95);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            backdrop-filter: blur(10px);
        }

        .audio-panel {
            background: rgba(15, 23, 42, 0.95);
            border-right: 1px solid rgba(148, 163, 184, 0.1);
            backdrop-filter: blur(10px);
        }

        /* Audio Knob */
        .audio-knob-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        .audio-knob {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: linear-gradient(145deg, #1e293b, #0f172a);
            border: 2px solid #334155;
            position: relative;
            cursor: pointer;
            transition: border-color 0.2s;
        }

        .audio-knob:hover {
            border-color: #6366f1;
        }

        .audio-knob::after {
            content: '';
            position: absolute;
            width: 3px;
            height: 12px;
            background: #94a3b8;
            top: 6px;
            left: 50%;
            transform-origin: bottom center;
            transform: translateX(-50%) rotate(var(--rotation, 0deg));
            border-radius: 2px;
        }

        .audio-knob.active::after {
            background: #6366f1;
        }

        .audio-knob-label {
            font-size: 10px;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .audio-knob-value {
            font-size: 11px;
            color: #94a3b8;
            font-family: monospace;
        }

        .knob-row {
            display: flex;
            justify-content: space-around;
            gap: 8px;
            padding: 8px 0;
        }

        /* Vertical Slider for Audio */
        .audio-slider-v {
            writing-mode: vertical-lr;
            direction: rtl;
            height: 80px;
            width: 6px;
            -webkit-appearance: none;
            background: #1e293b;
            border-radius: 3px;
            outline: none;
        }

        .audio-slider-v::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .slider-container {
            position: relative;
        }

        .slider-track {
            height: 6px;
            background: #1e293b;
            border-radius: 3px;
            overflow: hidden;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #8b5cf6);
            transition: width 0.1s ease;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: transparent;
            position: absolute;
            top: 0;
            left: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #fff;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .tension-bar {
            height: 8px;
            background: #1e293b;
            border-radius: 4px;
            overflow: hidden;
        }

        .tension-fill {
            height: 100%;
            transition: width 0.3s ease, background 0.3s ease;
        }

        .key-btn {
            padding: 6px 12px;
            background: #1e293b;
            border: 1px solid #334155;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 13px;
        }

        .key-btn:hover {
            background: #334155;
        }

        .key-btn.active {
            background: #3b82f6;
            border-color: #3b82f6;
        }

        .style-radio {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 4px 0;
        }

        .style-radio input {
            display: none;
        }

        .style-radio .radio-dot {
            width: 16px;
            height: 16px;
            border: 2px solid #475569;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .style-radio input:checked + .radio-dot {
            border-color: #3b82f6;
        }

        .style-radio input:checked + .radio-dot::after {
            content: '';
            width: 8px;
            height: 8px;
            background: #3b82f6;
            border-radius: 50%;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .play-btn.play {
            background: #22c55e;
        }

        .play-btn.pause {
            background: #f59e0b;
        }

        .play-btn:hover {
            transform: scale(1.1);
        }

        .info-panel {
            background: rgba(15, 23, 42, 0.8);
            border-top: 1px solid rgba(148, 163, 184, 0.1);
        }

        .cadence-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .cadence-autentica { background: #166534; color: #bbf7d0; }
        .cadence-plagal { background: #1e40af; color: #bfdbfe; }
        .cadence-rota { background: #9f1239; color: #fecdd3; }
        .cadence-semi { background: #854d0e; color: #fef08a; }
        .cadence-frigia { background: #581c87; color: #e9d5ff; }

        /* Voice Mixer */
        .voice-mixer {
            display: flex;
            justify-content: space-around;
            gap: 8px;
            padding: 12px 8px;
            background: #0f172a;
            border-radius: 8px;
        }

        .voice-channel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 6px;
            min-width: 48px;
        }

        .voice-label {
            font-size: 11px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .voice-led {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #1e293b;
            transition: all 0.1s ease;
        }

        .voice-led.active {
            box-shadow: 0 0 8px currentColor;
        }

        .voice-channel[data-voice="0"] .voice-led { color: #f97316; }
        .voice-channel[data-voice="1"] .voice-led { color: #22c55e; }
        .voice-channel[data-voice="2"] .voice-led { color: #3b82f6; }
        .voice-channel[data-voice="3"] .voice-led { color: #a855f7; }

        .voice-channel[data-voice="0"] .voice-led.active { background: #f97316; }
        .voice-channel[data-voice="1"] .voice-led.active { background: #22c55e; }
        .voice-channel[data-voice="2"] .voice-led.active { background: #3b82f6; }
        .voice-channel[data-voice="3"] .voice-led.active { background: #a855f7; }

        .voice-fader-container {
            position: relative;
            width: 24px;
            height: 80px;
            background: #1e293b;
            border-radius: 4px;
            overflow: hidden;
        }

        .voice-fader-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            border-radius: 4px;
            transition: height 0.1s ease;
        }

        .voice-channel[data-voice="0"] .voice-fader-fill { background: linear-gradient(to top, #f97316, #fb923c); }
        .voice-channel[data-voice="1"] .voice-fader-fill { background: linear-gradient(to top, #22c55e, #4ade80); }
        .voice-channel[data-voice="2"] .voice-fader-fill { background: linear-gradient(to top, #3b82f6, #60a5fa); }
        .voice-channel[data-voice="3"] .voice-fader-fill { background: linear-gradient(to top, #a855f7, #c084fc); }

        .voice-fader {
            position: absolute;
            width: 80px;
            height: 24px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) rotate(-90deg);
            -webkit-appearance: none;
            background: transparent;
            cursor: pointer;
        }

        .voice-fader::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 10px;
            background: #fff;
            border-radius: 2px;
            cursor: pointer;
            box-shadow: 0 1px 4px rgba(0,0,0,0.4);
        }

        .voice-mute {
            width: 28px;
            height: 20px;
            border: none;
            border-radius: 4px;
            background: #334155;
            color: #94a3b8;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .voice-mute:hover {
            background: #475569;
        }

        .voice-mute.muted {
            background: #ef4444;
            color: #fff;
        }

        .voice-note-display {
            font-size: 10px;
            font-family: monospace;
            color: #64748b;
            min-width: 28px;
            text-align: center;
        }

        /* Voice Trail Visualization */
        .voice-trail-container {
            margin-top: 12px;
            background: #0f172a;
            border-radius: 6px;
            padding: 8px;
            position: relative;
        }

        .voice-trail-labels {
            position: absolute;
            right: 4px;
            top: 8px;
            bottom: 8px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            font-size: 8px;
            color: #475569;
        }

        #voiceTrail {
            width: 100%;
            height: 80px;
            display: block;
        }

        .bass-line-viz {
            height: 40px;
            background: #0f172a;
            border-radius: 4px;
            display: flex;
            align-items: flex-end;
            gap: 2px;
            padding: 4px;
        }

        .bass-bar {
            flex: 1;
            background: #3b82f6;
            border-radius: 2px 2px 0 0;
            transition: height 0.2s ease;
        }

        .prob-row {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
        }

        .prob-label {
            width: 32px;
            font-family: monospace;
            color: #94a3b8;
        }

        .prob-bar-container {
            flex: 1;
            height: 12px;
            background: #1e293b;
            border-radius: 2px;
            overflow: hidden;
        }

        .prob-bar {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .prob-value {
            width: 36px;
            text-align: right;
            font-family: monospace;
            color: #64748b;
        }

        .prob-bar.func-T { background: #22c55e; }
        .prob-bar.func-S { background: #3b82f6; }
        .prob-bar.func-D { background: #ef4444; }

        /* Matriz de transiciones */
        .matrix-container {
            font-size: 10px;
            overflow: hidden;
            max-height: 200px;
            transition: max-height 0.3s ease, opacity 0.2s ease;
        }

        .matrix-container.collapsed {
            max-height: 0;
            opacity: 0;
        }

        .matrix-chevron-rotated {
            transform: rotate(-90deg);
        }

        .matrix-grid {
            display: grid;
            grid-template-columns: 28px repeat(7, 1fr);
            gap: 1px;
        }

        .matrix-cell {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 8px;
            border-radius: 2px;
            transition: background 0.2s ease;
        }

        .matrix-header {
            color: #94a3b8;
            font-weight: 500;
            font-size: 9px;
        }

        .matrix-row-label {
            color: #94a3b8;
            font-weight: 500;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .matrix-cell.current-row {
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.3);
        }

        /* BotÃ³n de caos */
        .chaos-btn {
            background: linear-gradient(135deg, #7c3aed, #ec4899);
            border: none;
            padding: 8px 16px;
            border-radius: 8px;
            color: white;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 12px;
        }

        .chaos-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(124, 58, 237, 0.5);
        }

        .chaos-btn:active {
            transform: scale(0.95);
        }

        .chaos-btn.active {
            animation: chaos-pulse 0.3s ease;
        }

        @keyframes chaos-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 30px rgba(236, 72, 153, 0.8); }
            100% { transform: scale(1); }
        }

        /* Barra de entropÃ­a */
        .entropy-bar {
            height: 6px;
            background: #1e293b;
            border-radius: 3px;
            overflow: hidden;
        }

        .entropy-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
            transition: width 0.3s ease;
        }

        @keyframes pulse-glow {
            0%, 100% { opacity: 0.5; }
            50% { opacity: 1; }
        }

        @keyframes resolution-burst {
            0% { transform: scale(0); opacity: 1; }
            100% { transform: scale(3); opacity: 0; }
        }

        .resolution-particle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #22c55e;
            animation: resolution-burst 0.5s ease-out forwards;
        }

        /* ModulaciÃ³n */
        .modulation-badge {
            font-size: 11px;
            font-weight: 600;
            padding: 2px 8px;
            border-radius: 10px;
            animation: modulation-pulse 0.5s ease;
        }

        .modulation-badge.preparing {
            background: rgba(168, 85, 247, 0.3);
            color: #c4b5fd;
            border: 1px solid #a855f7;
        }

        .modulation-badge.complete {
            background: rgba(34, 197, 94, 0.3);
            color: #86efac;
            border: 1px solid #22c55e;
        }

        @keyframes modulation-pulse {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); opacity: 1; }
        }

        #currentKeyDisplay {
            transition: all 0.3s ease;
        }

        #currentKeyDisplay.key-changed {
            color: #a855f7;
            transform: scale(1.2);
            text-shadow: 0 0 20px rgba(168, 85, 247, 0.8);
        }

        /* Theory Modal */
        .theory-modal {
            max-width: 720px;
            max-height: 85vh;
            display: flex;
            flex-direction: column;
            background: #1e293b;
            border-radius: 16px;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .theory-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.25rem 1.5rem;
            border-bottom: 1px solid #334155;
        }

        .theory-header h2 {
            margin: 0;
            font-size: 1.25rem;
            color: #f1f5f9;
        }

        .theory-close {
            background: none;
            border: none;
            color: #64748b;
            cursor: pointer;
            padding: 4px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .theory-close:hover {
            color: #f1f5f9;
            background: #334155;
        }

        .theory-content {
            overflow-y: auto;
            padding: 1.5rem;
        }

        .theory-section {
            margin-bottom: 1.75rem;
            padding-bottom: 1.25rem;
            border-bottom: 1px solid #334155;
        }

        .theory-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .theory-section h3 {
            color: #a78bfa;
            font-size: 1rem;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .theory-section h4 {
            color: #e2e8f0;
            font-size: 0.9rem;
            margin: 1rem 0 0.5rem 0;
        }

        .theory-section p {
            color: #94a3b8;
            margin-bottom: 0.75rem;
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .theory-section ul {
            margin-left: 1.25rem;
            margin-bottom: 0.75rem;
        }

        .theory-section li {
            color: #94a3b8;
            font-size: 0.875rem;
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }

        .theory-table {
            width: 100%;
            border-collapse: collapse;
            margin: 0.75rem 0;
            font-size: 0.8rem;
        }

        .theory-table th,
        .theory-table td {
            padding: 0.5rem 0.75rem;
            text-align: left;
            border: 1px solid #334155;
        }

        .theory-table th {
            background: #0f172a;
            color: #e2e8f0;
            font-weight: 500;
        }

        .theory-table td {
            color: #94a3b8;
        }

        .theory-table .func-T { color: #22c55e; font-weight: 500; }
        .theory-table .func-S { color: #3b82f6; font-weight: 500; }
        .theory-table .func-D { color: #ef4444; font-weight: 500; }
        .theory-table .func-note { color: #fbbf24; }

        .theory-note {
            background: #0f172a;
            padding: 0.75rem 1rem;
            border-radius: 8px;
            font-size: 0.8rem;
            border-left: 3px solid #a78bfa;
            color: #cbd5e1;
        }

        .theory-quote {
            font-style: italic;
            color: #94a3b8;
            border-left: 3px solid #475569;
            padding-left: 1rem;
            margin: 1rem 0;
        }

        .theory-diagram {
            background: #0f172a;
            border-radius: 8px;
            padding: 1rem;
            font-family: monospace;
            font-size: 0.75rem;
            color: #94a3b8;
            text-align: center;
            overflow-x: auto;
        }

        .theory-source {
            opacity: 0.7;
            font-style: italic;
            font-size: 0.8rem;
            color: #64748b;
        }
    </style>
</head>
<body class="h-screen flex flex-col">
    <!-- Header -->
    <header class="flex items-center justify-between px-6 py-3 bg-slate-900/80 border-b border-slate-700/50">
        <div class="flex items-center gap-3">
            <h1 class="text-lg font-semibold text-white">Rameau Machine</h1>
            <span class="text-xs text-slate-400 bg-slate-800 px-2 py-1 rounded">Armonia Funcional</span>
        </div>
        <div class="flex items-center gap-4">
            <button id="helpBtn" class="text-slate-400 hover:text-white transition-colors flex items-center gap-1.5" title="Teoria">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                </svg>
                <span class="text-xs">Teoria</span>
            </button>
            <button id="menuBtn" class="text-slate-400 hover:text-white transition-colors">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16m-7 6h7"/>
                </svg>
            </button>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex overflow-hidden">
        <!-- Audio Panel (Left) -->
        <aside class="audio-panel w-64 flex flex-col">
            <div class="p-3 space-y-4 overflow-y-auto flex-1">
                <!-- Master -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3 text-center">Master</h3>
                    <div class="flex justify-center">
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobMaster" data-value="70" style="--rotation: 90deg"></div>
                            <span class="audio-knob-value" id="masterValue">70%</span>
                        </div>
                    </div>
                </section>

                <!-- Reverb & Filter -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3 text-center">Espacio</h3>
                    <div class="knob-row">
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobReverb" data-value="30" style="--rotation: -36deg"></div>
                            <span class="audio-knob-label">Reverb</span>
                            <span class="audio-knob-value" id="reverbValue">30%</span>
                        </div>
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobFilter" data-value="80" style="--rotation: 108deg"></div>
                            <span class="audio-knob-label">Brillo</span>
                            <span class="audio-knob-value" id="filterValue">80%</span>
                        </div>
                    </div>
                </section>

                <!-- Detune & Vibrato -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3 text-center">Color</h3>
                    <div class="knob-row">
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobDetune" data-value="50" style="--rotation: 0deg"></div>
                            <span class="audio-knob-label">Detune</span>
                            <span class="audio-knob-value" id="detuneValue">50%</span>
                        </div>
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobVibrato" data-value="30" style="--rotation: -36deg"></div>
                            <span class="audio-knob-label">Vibrato</span>
                            <span class="audio-knob-value" id="vibratoValue">30%</span>
                        </div>
                    </div>
                </section>

                <!-- Attack & Release -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3 text-center">Envolvente</h3>
                    <div class="knob-row">
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobAttack" data-value="20" style="--rotation: -72deg"></div>
                            <span class="audio-knob-label">Attack</span>
                            <span class="audio-knob-value" id="attackValue">20%</span>
                        </div>
                        <div class="audio-knob-container">
                            <div class="audio-knob" id="knobRelease" data-value="40" style="--rotation: -18deg"></div>
                            <span class="audio-knob-label">Release</span>
                            <span class="audio-knob-value" id="releaseValue">40%</span>
                        </div>
                    </div>
                </section>

                <!-- Voice Mixer -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3 text-center">Voces</h3>
                    <div class="voice-mixer" id="voiceMixer">
                        <!-- Bajo -->
                        <div class="voice-channel" data-voice="0">
                            <span class="voice-label">B</span>
                            <div class="voice-led" id="led-0"></div>
                            <div class="voice-fader-container">
                                <div class="voice-fader-fill" id="faderFill-0" style="height: 80%"></div>
                                <input type="range" class="voice-fader" id="fader-0" min="0" max="100" value="80">
                            </div>
                            <button class="voice-mute" id="mute-0">M</button>
                            <span class="voice-note-display" id="note-0">--</span>
                        </div>
                        <!-- Tenor -->
                        <div class="voice-channel" data-voice="1">
                            <span class="voice-label">T</span>
                            <div class="voice-led" id="led-1"></div>
                            <div class="voice-fader-container">
                                <div class="voice-fader-fill" id="faderFill-1" style="height: 80%"></div>
                                <input type="range" class="voice-fader" id="fader-1" min="0" max="100" value="80">
                            </div>
                            <button class="voice-mute" id="mute-1">M</button>
                            <span class="voice-note-display" id="note-1">--</span>
                        </div>
                        <!-- Alto -->
                        <div class="voice-channel" data-voice="2">
                            <span class="voice-label">A</span>
                            <div class="voice-led" id="led-2"></div>
                            <div class="voice-fader-container">
                                <div class="voice-fader-fill" id="faderFill-2" style="height: 80%"></div>
                                <input type="range" class="voice-fader" id="fader-2" min="0" max="100" value="80">
                            </div>
                            <button class="voice-mute" id="mute-2">M</button>
                            <span class="voice-note-display" id="note-2">--</span>
                        </div>
                        <!-- Soprano -->
                        <div class="voice-channel" data-voice="3">
                            <span class="voice-label">S</span>
                            <div class="voice-led" id="led-3"></div>
                            <div class="voice-fader-container">
                                <div class="voice-fader-fill" id="faderFill-3" style="height: 80%"></div>
                                <input type="range" class="voice-fader" id="fader-3" min="0" max="100" value="80">
                            </div>
                            <button class="voice-mute" id="mute-3">M</button>
                            <span class="voice-note-display" id="note-3">--</span>
                        </div>
                    </div>
                    <!-- Voice Trail Visualization -->
                    <div class="voice-trail-container mt-2">
                        <canvas id="voiceTrail"></canvas>
                        <div class="voice-trail-labels">
                            <span style="color: #a855f7">S</span>
                            <span style="color: #3b82f6">A</span>
                            <span style="color: #22c55e">T</span>
                            <span style="color: #f97316">B</span>
                        </div>
                    </div>
                </section>
            </div>
        </aside>

        <!-- Visualization Area -->
        <div class="flex-1 relative" id="vizContainer">
            <svg id="mainSvg" class="w-full h-full"></svg>
            <div id="particles" class="absolute inset-0 pointer-events-none"></div>
        </div>

        <!-- Control Panel (Right) -->
        <aside class="control-panel w-64 flex flex-col">
            <div class="p-4 space-y-5 overflow-y-auto flex-1">
                <!-- Tonalidad -->
                <section>
                    <div class="flex justify-between items-center mb-3">
                        <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Tonalidad</h3>
                        <div class="flex items-center gap-2">
                            <span class="text-2xl font-bold text-white" id="currentKeyDisplay">C</span>
                            <span id="modulationBadge" class="modulation-badge" style="display: none;"></span>
                        </div>
                    </div>
                    <div class="grid grid-cols-6 gap-1" id="keySelector">
                        <button class="key-btn active" data-key="C">C</button>
                        <button class="key-btn" data-key="G">G</button>
                        <button class="key-btn" data-key="D">D</button>
                        <button class="key-btn" data-key="A">A</button>
                        <button class="key-btn" data-key="E">E</button>
                        <button class="key-btn" data-key="B">B</button>
                        <button class="key-btn" data-key="F">F</button>
                        <button class="key-btn" data-key="Bb">Bb</button>
                        <button class="key-btn" data-key="Eb">Eb</button>
                        <button class="key-btn" data-key="Ab">Ab</button>
                        <button class="key-btn" data-key="Db">Db</button>
                        <button class="key-btn" data-key="Gb">Gb</button>
                    </div>
                    <!-- Toggle Mayor/Menor -->
                    <div class="flex items-center gap-3 mt-3">
                        <span class="text-xs text-slate-400" id="modeLabel">Mayor</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="modeToggle" class="sr-only peer">
                            <div class="w-11 h-6 bg-green-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                        </label>
                        <span class="text-xs text-slate-500">Menor</span>
                    </div>
                    <!-- Toggle ModulaciÃ³n AutomÃ¡tica -->
                    <div class="flex items-center justify-between mt-3 pt-3 border-t border-slate-700">
                        <span class="text-xs text-slate-400">ModulaciÃ³n Auto</span>
                        <label class="relative inline-flex items-center cursor-pointer">
                            <input type="checkbox" id="modulationToggle" class="sr-only peer">
                            <div class="w-9 h-5 bg-slate-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-purple-600"></div>
                        </label>
                    </div>
                    <!-- BotÃ³n ModulaciÃ³n Manual -->
                    <button id="modulateBtn" class="w-full mt-2 px-3 py-2 bg-purple-600/20 hover:bg-purple-600/40 border border-purple-500/50 rounded-lg text-purple-300 text-xs font-medium transition-all flex items-center justify-center gap-2">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16V4m0 0L3 8m4-4l4 4m6 0v12m0 0l4-4m-4 4l-4-4"/>
                        </svg>
                        Modular
                    </button>
                </section>

                <!-- Tempo -->
                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Tempo</h3>
                        <span class="text-sm font-mono text-slate-300" id="tempoValue">80 BPM</span>
                    </div>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-fill" id="tempoFill" style="width: 40%"></div>
                        </div>
                        <input type="range" id="tempoSlider" min="40" max="140" value="80">
                    </div>
                </section>

                <!-- Tension -->
                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Tension</h3>
                        <span class="text-sm font-mono" id="tensionValue">0.00</span>
                    </div>
                    <div class="tension-bar">
                        <div class="tension-fill" id="tensionFill" style="width: 0%; background: #22c55e;"></div>
                    </div>
                </section>

                <!-- Gravedad Tonal -->
                <section>
                    <div class="flex justify-between items-center mb-2">
                        <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Gravedad Tonal</h3>
                        <span class="text-sm font-mono text-slate-300" id="gravityValue">50%</span>
                    </div>
                    <div class="slider-container">
                        <div class="slider-track">
                            <div class="slider-fill" id="gravityFill" style="width: 50%"></div>
                        </div>
                        <input type="range" id="gravitySlider" min="0" max="100" value="50">
                    </div>
                    <div class="flex justify-between text-xs text-slate-500 mt-1">
                        <span>Caos</span>
                        <span>Estricto</span>
                    </div>
                </section>

                <!-- Caos y EntropÃ­a -->
                <section>
                    <div class="flex items-center justify-between mb-2">
                        <button id="chaosBtn" class="chaos-btn">
                            ðŸ’¥ Inyectar Caos
                        </button>
                        <div class="text-right">
                            <span class="text-xs text-slate-500">Caos: </span>
                            <span class="text-xs font-mono text-purple-400" id="chaosLevel">0%</span>
                        </div>
                    </div>
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-xs text-slate-500">EntropÃ­a</span>
                        <span class="text-xs font-mono text-slate-400" id="entropyValue">0.50</span>
                    </div>
                    <div class="entropy-bar">
                        <div class="entropy-fill" id="entropyFill" style="width: 50%"></div>
                    </div>
                </section>

                <!-- Matriz de Transiciones -->
                <section>
                    <div class="flex justify-between items-center mb-2 cursor-pointer select-none" id="matrixHeader">
                        <div class="flex items-center gap-2">
                            <svg class="w-3 h-3 text-slate-500 transition-transform" id="matrixChevron" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                            </svg>
                            <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider">Matriz P(j|i)</h3>
                        </div>
                        <span class="text-xs text-slate-500">desde <span id="currentChordLabel" class="text-white font-mono">I</span></span>
                    </div>
                    <div class="matrix-container" id="matrixDisplay">
                        <!-- Se llena dinÃ¡micamente -->
                    </div>
                </section>

                <!-- Probabilidades (barras) -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-2">Siguiente â†’</h3>
                    <div class="space-y-1" id="probDisplay">
                        <!-- Se llena dinÃ¡micamente -->
                    </div>
                </section>

                <!-- Estilo -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3">Estilo</h3>
                    <div class="space-y-1">
                        <label class="style-radio">
                            <input type="radio" name="style" value="barroco">
                            <span class="radio-dot"></span>
                            <span class="text-sm text-slate-300">Barroco</span>
                        </label>
                        <label class="style-radio">
                            <input type="radio" name="style" value="clasico" checked>
                            <span class="radio-dot"></span>
                            <span class="text-sm text-slate-300">Clasico</span>
                        </label>
                        <label class="style-radio">
                            <input type="radio" name="style" value="romantico">
                            <span class="radio-dot"></span>
                            <span class="text-sm text-slate-300">Romantico</span>
                        </label>
                        <label class="style-radio">
                            <input type="radio" name="style" value="jazz">
                            <span class="radio-dot"></span>
                            <span class="text-sm text-slate-300">Jazz</span>
                        </label>
                    </div>
                </section>

                <!-- Modo -->
                <section>
                    <h3 class="text-xs font-medium text-slate-400 uppercase tracking-wider mb-3">Modo</h3>
                    <div class="flex gap-2">
                        <button class="flex-1 py-2 px-3 bg-blue-600 text-white text-xs font-medium rounded-lg" id="modeAuto">
                            Autonomo
                        </button>
                        <button class="flex-1 py-2 px-3 bg-slate-700 text-slate-300 text-xs font-medium rounded-lg" id="modeGuided">
                            Guiado
                        </button>
                    </div>
                </section>

            </div>

            <!-- Transport Controls -->
            <div class="p-4 border-t border-slate-700/50 flex items-center justify-center gap-4">
                <button id="resetBtn" class="w-10 h-10 rounded-full bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/>
                    </svg>
                </button>
                <button id="playBtn" class="play-btn play">
                    <svg class="w-6 h-6" fill="currentColor" viewBox="0 0 24 24" id="playIcon">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                </button>
                <button id="recordBtn" class="w-10 h-10 rounded-full bg-slate-700 hover:bg-red-600 flex items-center justify-center transition-colors" title="Grabar audio">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24" id="recordIcon">
                        <circle cx="12" cy="12" r="6"/>
                    </svg>
                </button>
                <button id="exportBtn" class="w-10 h-10 rounded-full bg-slate-700 hover:bg-slate-600 flex items-center justify-center transition-colors" title="Exportar texto">
                    <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M19 9h-4V3H9v6H5l7 7 7-7zM5 18v2h14v-2H5z"/>
                    </svg>
                </button>
                <button id="exportXMLBtn" class="w-10 h-10 rounded-full bg-slate-700 hover:bg-indigo-600 flex items-center justify-center transition-colors" title="Exportar MusicXML (SATB)">
                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l12-3v13M9 19c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zm12-3c0 1.105-1.343 2-3 2s-3-.895-3-2 1.343-2 3-2 3 .895 3 2zM9 10l12-3"/>
                    </svg>
                </button>
            </div>
        </aside>
    </main>

    <!-- Info Bar -->
    <footer class="info-panel px-6 py-3 flex items-center justify-between">
        <div class="flex items-center gap-6">
            <div>
                <span class="text-xs text-slate-500">Progresion:</span>
                <span class="text-sm font-mono text-slate-300 ml-2" id="progressionDisplay">I</span>
            </div>
            <div>
                <span class="text-xs text-slate-500">Bajo:</span>
                <span class="text-sm font-mono text-slate-300 ml-2" id="bassDisplay">C</span>
            </div>
            <div>
                <span class="text-xs text-slate-500">Cadencia:</span>
                <span class="ml-2" id="cadenceDisplay">-</span>
            </div>
        </div>
        <div class="bass-line-viz w-48" id="bassViz"></div>
    </footer>

    <!-- Theory Modal -->
    <div id="helpModal" class="fixed inset-0 bg-black/80 flex items-center justify-center z-50 hidden" style="backdrop-filter: blur(4px);">
        <div class="theory-modal mx-4">
            <div class="theory-header">
                <h2>Armonia Funcional</h2>
                <button id="closeHelp" class="theory-close">
                    <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
            <div class="theory-content">
                <!-- Â§1 Introduccion -->
                <section class="theory-section">
                    <h3>Â§1. Que es la Armonia Funcional</h3>
                    <p>La armonia funcional es un sistema para entender <strong>por que</strong> los acordes se mueven como lo hacen. En lugar de memorizar progresiones, comprendemos la <em>funcion</em> de cada acorde dentro de la tonalidad.</p>
                    <p>Jean-Philippe Rameau (1683-1764) revoluciono la teoria musical con su <em>Traite de l'harmonie</em> (1722), donde establecio que los acordes tienen funciones especificas que generan tension y resolucion.</p>
                    <div class="theory-quote">
                        "La melodia nace de la armonia." â€” Jean-Philippe Rameau
                    </div>
                </section>

                <!-- Â§2 Las Tres Funciones -->
                <section class="theory-section">
                    <h3>Â§2. Las Tres Funciones: T - S - D</h3>
                    <p>Todo acorde cumple una de tres funciones:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Funcion</th>
                            <th>Acordes</th>
                            <th>Sensacion</th>
                        </tr>
                        <tr>
                            <td class="func-T">Tonica (T)</td>
                            <td>I, vi, iii</td>
                            <td>Reposo, llegada, estabilidad</td>
                        </tr>
                        <tr>
                            <td class="func-S">Subdominante (S)</td>
                            <td>IV, ii</td>
                            <td>Alejamiento, movimiento, preparacion</td>
                        </tr>
                        <tr>
                            <td class="func-D">Dominante (D)</td>
                            <td>V, viiÂ°</td>
                            <td>Tension, urgencia de resolver</td>
                        </tr>
                    </table>
                    <div class="theory-diagram">
T (reposo) â†’ S (alejarse) â†’ D (tension) â†’ T (resolucion)<br><br>
    I  â”€â”€â”€â”€â†’   IV  â”€â”€â”€â”€â†’   V  â”€â”€â”€â”€â†’   I
                    </div>
                </section>

                <!-- Â§3 Acordes en Mayor -->
                <section class="theory-section">
                    <h3>Â§3. Los Siete Acordes de la Escala Mayor</h3>
                    <p>En Do mayor, los acordes diatonicos son:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Grado</th>
                            <th>Acorde</th>
                            <th>Cualidad</th>
                            <th>Funcion</th>
                        </tr>
                        <tr><td>I</td><td>C</td><td>Mayor</td><td class="func-T">Tonica</td></tr>
                        <tr><td>ii</td><td>Dm</td><td>Menor</td><td class="func-S">Subdominante</td></tr>
                        <tr><td>iii</td><td>Em</td><td>Menor</td><td class="func-T">Tonica (debil)</td></tr>
                        <tr><td>IV</td><td>F</td><td>Mayor</td><td class="func-S">Subdominante</td></tr>
                        <tr><td>V</td><td>G</td><td>Mayor</td><td class="func-D">Dominante</td></tr>
                        <tr><td>vi</td><td>Am</td><td>Menor</td><td class="func-T">Tonica (relativo)</td></tr>
                        <tr><td>viiÂ°</td><td>Bdim</td><td>Disminuido</td><td class="func-D">Dominante</td></tr>
                    </table>
                </section>

                <!-- Â§4 Tension y Gravedad -->
                <section class="theory-section">
                    <h3>Â§4. Tension y Gravedad Tonal</h3>
                    <p>Cada acorde tiene un nivel de <strong>tension</strong> que determina su "urgencia" por resolver:</p>
                    <ul>
                        <li><strong>Tension baja (0-0.3):</strong> Acordes de tonica. Estables, pueden mantenerse.</li>
                        <li><strong>Tension media (0.4-0.6):</strong> Acordes de subdominante. Crean movimiento.</li>
                        <li><strong>Tension alta (0.7-1.0):</strong> Acordes de dominante. Exigen resolucion.</li>
                    </ul>
                    <p>La <strong>gravedad tonal</strong> simula como los acordes de alta tension son "atraidos" hacia la tonica, como un objeto cayendo.</p>
                    <div class="theory-note">
                        En el visualizador: cuanto mas se llena la barra de tension, mas probable es que el siguiente acorde sea de tonica.
                    </div>
                </section>

                <!-- Â§5 Cadencias -->
                <section class="theory-section">
                    <h3>Â§5. Cadencias</h3>
                    <p>Las <strong>cadencias</strong> son formulas de cierre que marcan puntos de descanso:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Cadencia</th>
                            <th>Movimiento</th>
                            <th>Efecto</th>
                        </tr>
                        <tr>
                            <td style="background:#166534; color:#bbf7d0;">Autentica</td>
                            <td>V â†’ I</td>
                            <td>Conclusion definitiva</td>
                        </tr>
                        <tr>
                            <td style="background:#1e40af; color:#bfdbfe;">Plagal</td>
                            <td>IV â†’ I</td>
                            <td>Cierre suave ("Amen")</td>
                        </tr>
                        <tr>
                            <td style="background:#854d0e; color:#fef08a;">Semicadencia</td>
                            <td>* â†’ V</td>
                            <td>Pausa expectante</td>
                        </tr>
                        <tr>
                            <td style="background:#9f1239; color:#fecdd3;">Rota (Deceptiva)</td>
                            <td>V â†’ vi</td>
                            <td>Sorpresa, continuacion</td>
                        </tr>
                    </table>
                </section>

                <!-- Â§6 Matriz de Transiciones -->
                <section class="theory-section">
                    <h3>Â§6. Matriz de Transiciones</h3>
                    <p>La matriz muestra la <strong>probabilidad</strong> de que un acorde vaya a otro. Basada en el analisis de miles de obras del repertorio clasico:</p>
                    <ul>
                        <li><strong>V â†’ I (70%):</strong> La resolucion mas fuerte y comun</li>
                        <li><strong>IV â†’ V (50%):</strong> Preparacion clasica de la dominante</li>
                        <li><strong>I â†’ IV (25%):</strong> Apertura tipica hacia la subdominante</li>
                        <li><strong>vi â†’ ii (25%):</strong> Circulo de quintas descendente</li>
                    </ul>
                    <div class="theory-note">
                        En el panel derecho puedes desplegar la matriz completa. Las celdas mas brillantes indican transiciones mas probables.
                    </div>
                </section>

                <!-- Â§7 Modulacion -->
                <section class="theory-section">
                    <h3>Â§7. Modulacion</h3>
                    <p>La <strong>modulacion</strong> es el cambio de una tonalidad a otra. En Rameau Machine, el sistema modula automaticamente a <strong>tonalidades relacionadas</strong>:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Relacion</th>
                            <th>Desde Do Mayor</th>
                            <th>Razon</th>
                        </tr>
                        <tr>
                            <td>Dominante</td>
                            <td>Sol Mayor</td>
                            <td>Una quinta ascendente (V)</td>
                        </tr>
                        <tr>
                            <td>Subdominante</td>
                            <td>Fa Mayor</td>
                            <td>Una quinta descendente (IV)</td>
                        </tr>
                        <tr>
                            <td>Relativo menor</td>
                            <td>La menor</td>
                            <td>Comparte armadura (vi)</td>
                        </tr>
                        <tr>
                            <td>Relativo mayor*</td>
                            <td>Mi bemol Mayor</td>
                            <td>Desde modo menor</td>
                        </tr>
                    </table>
                    <h4>El Circulo de Quintas</h4>
                    <div class="theory-diagram">
        Fa â† Do â†’ Sol<br>
         â†“         â†“<br>
     re menor   mi menor<br><br>
Movimiento por quintas = modulaciones naturales
                    </div>
                    <div class="theory-note">
                        El boton "Modular" en el panel derecho te permite forzar una modulacion manual. Observa como la visualizacion y los acordes se adaptan a la nueva tonalidad.
                    </div>
                </section>

                <!-- Â§8 Conduccion de Voces -->
                <section class="theory-section">
                    <h3>Â§8. Conduccion de Voces (SATB)</h3>
                    <p>El sintetizador usa cuatro voces, como un coro:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Voz</th>
                            <th>Rango</th>
                            <th>Rol</th>
                        </tr>
                        <tr>
                            <td style="color:#a855f7;">Soprano (S)</td>
                            <td>C4 - G5</td>
                            <td>Melodia, linea superior</td>
                        </tr>
                        <tr>
                            <td style="color:#3b82f6;">Alto (A)</td>
                            <td>G3 - D5</td>
                            <td>Armonia interna</td>
                        </tr>
                        <tr>
                            <td style="color:#22c55e;">Tenor (T)</td>
                            <td>C3 - G4</td>
                            <td>Armonia interna</td>
                        </tr>
                        <tr>
                            <td style="color:#f97316;">Bajo (B)</td>
                            <td>E2 - C4</td>
                            <td>Fundamental, soporte</td>
                        </tr>
                    </table>
                    <h4>Principios de Conduccion</h4>
                    <ul>
                        <li><strong>Movimiento minimo:</strong> Cada voz busca la nota mas cercana del siguiente acorde</li>
                        <li><strong>Evitar paralelas:</strong> Octavas y quintas paralelas debilitan la independencia</li>
                        <li><strong>Resolver sensibles:</strong> La septima sube al grado I, el tritono resuelve</li>
                    </ul>
                </section>

                <!-- Â§9 Estilos -->
                <section class="theory-section">
                    <h3>Â§9. Estilos Historicos</h3>
                    <p>Cada estilo aplica reglas diferentes de conduccion:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Estilo</th>
                            <th>Paralelas</th>
                            <th>Saltos</th>
                            <th>Timbre</th>
                        </tr>
                        <tr>
                            <td>Barroco</td>
                            <td>Estricto</td>
                            <td>PequeÃ±os</td>
                            <td>Organo, claro</td>
                        </tr>
                        <tr>
                            <td>Clasico</td>
                            <td>Estricto</td>
                            <td>Moderados</td>
                            <td>Cuerdas suaves</td>
                        </tr>
                        <tr>
                            <td>Romantico</td>
                            <td>Flexible</td>
                            <td>Amplios</td>
                            <td>Cuerdas ricas</td>
                        </tr>
                        <tr>
                            <td>Jazz</td>
                            <td>Libre</td>
                            <td>Libres</td>
                            <td>Electrico, brillante</td>
                        </tr>
                    </table>
                </section>

                <!-- Â§10 Modo Menor -->
                <section class="theory-section">
                    <h3>Â§10. Modo Menor</h3>
                    <p>El modo menor utiliza la <strong>escala menor armonica</strong> para mantener una dominante fuerte:</p>
                    <table class="theory-table">
                        <tr>
                            <th>Grado</th>
                            <th>Acorde</th>
                            <th>Funcion</th>
                        </tr>
                        <tr><td>i</td><td>Am</td><td class="func-T">Tonica</td></tr>
                        <tr><td>iiÂ°</td><td>Bdim</td><td class="func-S">Subdominante</td></tr>
                        <tr><td>III</td><td>C</td><td class="func-T">Tonica (relativo)</td></tr>
                        <tr><td>iv</td><td>Dm</td><td class="func-S">Subdominante</td></tr>
                        <tr><td>V</td><td>E (Â¡Mayor!)</td><td class="func-D">Dominante</td></tr>
                        <tr><td>VI</td><td>F</td><td class="func-T">Tonica</td></tr>
                        <tr><td>viiÂ°</td><td>G#dim</td><td class="func-D">Dominante</td></tr>
                    </table>
                    <div class="theory-note">
                        El V grado es mayor incluso en menor (E en vez de Em) porque contiene la <strong>sensible</strong> (G#) que resuelve a la tonica.
                    </div>
                </section>

                <!-- Fuentes -->
                <section class="theory-section" style="opacity: 0.7;">
                    <h3>Referencias</h3>
                    <p class="theory-source">
                        Rameau, J.-P. (1722). <em>Traite de l'harmonie reduite a ses principes naturels</em><br>
                        Riemann, H. (1893). <em>Vereinfachte Harmonielehre</em><br>
                        Piston, W. (1941). <em>Harmony</em>
                    </p>
                </section>
            </div>
        </div>
    </div>

    <script>
    // ============================================================
    // CONSTANTES Y CONFIGURACION
    // ============================================================

    const KEY_PITCHES = {
        'C': 0, 'C#': 1, 'Db': 1, 'D': 2, 'D#': 3, 'Eb': 3,
        'E': 4, 'F': 5, 'F#': 6, 'Gb': 6, 'G': 7, 'G#': 8,
        'Ab': 8, 'A': 9, 'A#': 10, 'Bb': 10, 'B': 11
    };

    const NOTE_NAMES = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

    const CHORDS = {
        'I':    { function: 'T', tension: 0.0, root: 0, third: 4, fifth: 7, quality: 'major' },
        'vi':   { function: 'T', tension: 0.2, root: 9, third: 0, fifth: 4, quality: 'minor' },
        'iii':  { function: 'T', tension: 0.3, root: 4, third: 7, fifth: 11, quality: 'minor' },
        'IV':   { function: 'S', tension: 0.4, root: 5, third: 9, fifth: 0, quality: 'major' },
        'ii':   { function: 'S', tension: 0.5, root: 2, third: 5, fifth: 9, quality: 'minor' },
        'V':    { function: 'D', tension: 0.8, root: 7, third: 11, fifth: 2, quality: 'major' },
        'V7':   { function: 'D', tension: 0.9, root: 7, third: 11, fifth: 2, seventh: 5, quality: 'dom7' },
        'viio': { function: 'D', tension: 0.85, root: 11, third: 2, fifth: 5, quality: 'dim' }
    };

    // Modo Menor (armÃ³nico): V siempre mayor para sensible
    const CHORDS_MINOR = {
        'i':    { function: 'T', tension: 0.0, root: 0, third: 3, fifth: 7, quality: 'minor' },
        'VI':   { function: 'T', tension: 0.25, root: 8, third: 0, fifth: 3, quality: 'major' },
        'III':  { function: 'T', tension: 0.3, root: 3, third: 7, fifth: 10, quality: 'major' },
        'iv':   { function: 'S', tension: 0.45, root: 5, third: 8, fifth: 0, quality: 'minor' },
        'iio':  { function: 'S', tension: 0.55, root: 2, third: 5, fifth: 8, quality: 'dim' },
        'V':    { function: 'D', tension: 0.8, root: 7, third: 11, fifth: 2, quality: 'major' },
        'viio': { function: 'D', tension: 0.85, root: 11, third: 2, fifth: 5, quality: 'dim' }
    };

    const FUNCTION_COLORS = {
        'T': '#22c55e',
        'S': '#3b82f6',
        'D': '#ef4444'
    };

    const DETAILED_TRANSITIONS = {
        'I':    { 'I': 0.05, 'ii': 0.15, 'iii': 0.05, 'IV': 0.25, 'V': 0.30, 'vi': 0.15, 'viio': 0.05 },
        'ii':   { 'I': 0.05, 'ii': 0.05, 'iii': 0.02, 'IV': 0.08, 'V': 0.60, 'vi': 0.05, 'viio': 0.15 },
        'iii':  { 'I': 0.10, 'ii': 0.05, 'iii': 0.02, 'IV': 0.30, 'V': 0.10, 'vi': 0.40, 'viio': 0.03 },
        'IV':   { 'I': 0.15, 'ii': 0.10, 'iii': 0.02, 'IV': 0.05, 'V': 0.50, 'vi': 0.05, 'viio': 0.13 },
        'V':    { 'I': 0.70, 'ii': 0.02, 'iii': 0.02, 'IV': 0.05, 'V': 0.05, 'vi': 0.14, 'viio': 0.02 },
        'vi':   { 'I': 0.10, 'ii': 0.25, 'iii': 0.05, 'IV': 0.30, 'V': 0.20, 'vi': 0.05, 'viio': 0.05 },
        'viio': { 'I': 0.80, 'ii': 0.02, 'iii': 0.05, 'IV': 0.02, 'V': 0.03, 'vi': 0.05, 'viio': 0.03 }
    };

    // Transiciones para modo menor armÃ³nico
    const TRANSITIONS_MINOR = {
        'i':    { 'i': 0.05, 'iio': 0.12, 'III': 0.08, 'iv': 0.25, 'V': 0.30, 'VI': 0.15, 'viio': 0.05 },
        'iio':  { 'i': 0.05, 'iio': 0.03, 'III': 0.02, 'iv': 0.10, 'V': 0.60, 'VI': 0.05, 'viio': 0.15 },
        'III':  { 'i': 0.12, 'iio': 0.05, 'III': 0.03, 'iv': 0.25, 'V': 0.10, 'VI': 0.40, 'viio': 0.05 },
        'iv':   { 'i': 0.10, 'iio': 0.08, 'III': 0.02, 'iv': 0.05, 'V': 0.55, 'VI': 0.05, 'viio': 0.15 },
        'V':    { 'i': 0.70, 'iio': 0.02, 'III': 0.02, 'iv': 0.03, 'V': 0.05, 'VI': 0.15, 'viio': 0.03 },
        'VI':   { 'i': 0.10, 'iio': 0.20, 'III': 0.10, 'iv': 0.30, 'V': 0.20, 'VI': 0.05, 'viio': 0.05 },
        'viio': { 'i': 0.80, 'iio': 0.02, 'III': 0.03, 'iv': 0.02, 'V': 0.05, 'VI': 0.05, 'viio': 0.03 }
    };

    const CADENCES = {
        'autentica_perfecta': { pattern: ['V', 'I'], strength: 1.0, class: 'cadence-autentica', label: 'Aut. Perfecta' },
        'autentica_imperfecta': { pattern: ['V7', 'I'], strength: 0.9, class: 'cadence-autentica', label: 'Aut. Imperfecta' },
        'plagal': { pattern: ['IV', 'I'], strength: 0.6, class: 'cadence-plagal', label: 'Plagal' },
        'semicadencia': { pattern: ['*', 'V'], strength: 0.5, class: 'cadence-semi', label: 'Semicadencia' },
        'rota': { pattern: ['V', 'vi'], strength: 0.7, class: 'cadence-rota', label: 'Rota (Deceptiva)' }
    };

    const VOICE_LEADING_RULES = {
        barroco: { strictParallels: true, resolveLeadingTone: true, maxLeap: 8 },
        clasico: { strictParallels: true, resolveLeadingTone: true, maxLeap: 10 },
        romantico: { strictParallels: false, resolveLeadingTone: false, maxLeap: 12 },
        jazz: { strictParallels: false, resolveLeadingTone: false, maxLeap: 14 }
    };

    const STYLES = {
        barroco: {
            tempo: 60,
            waveform: 'triangle',
            bassStyle: 'walking',
            // Ã“rgano positivo - brillante y claro
            filterMult: 1.3,        // Filtros mÃ¡s abiertos
            vibratoMult: 0.3,       // Poco vibrato (Ã³rgano no vibra)
            attackMult: 0.7,        // Ataque mÃ¡s rÃ¡pido
            reverbMix: 0.4,         // MÃ¡s reverb (iglesia)
            reverbSize: 0.8,
            harmonics: [1, 0.5, 0.25], // 8', 4', 2' (fundamental + octavas)
            unisonWidth: 0.3        // Menos chorus
        },
        clasico: {
            tempo: 80,
            waveform: 'triangle',
            bassStyle: 'alberti',
            // Cuerdas suaves - cÃ¡lido y redondo
            filterMult: 1.0,
            vibratoMult: 0.8,
            attackMult: 1.0,
            reverbMix: 0.3,
            reverbSize: 0.7,
            harmonics: [1, 0.3, 0.1],
            unisonWidth: 1.0
        },
        romantico: {
            tempo: 70,
            waveform: 'sawtooth',
            bassStyle: 'octaves',
            // Cuerdas expresivas - rico y dramÃ¡tico
            filterMult: 1.2,
            vibratoMult: 1.5,       // MÃ¡s vibrato
            attackMult: 1.3,        // Ataque mÃ¡s suave
            reverbMix: 0.45,
            reverbSize: 0.85,
            harmonics: [1, 0.6, 0.3, 0.15],
            unisonWidth: 1.5        // MÃ¡s chorus
        },
        jazz: {
            tempo: 120,
            waveform: 'sine',
            bassStyle: 'walking',
            // Piano elÃ©ctrico - limpio con overtones
            filterMult: 0.8,        // MÃ¡s oscuro
            vibratoMult: 0.5,
            attackMult: 0.5,        // Ataque percusivo
            reverbMix: 0.25,
            reverbSize: 0.5,
            harmonics: [1, 0.7, 0, 0.2], // Fundamental + 2nd + 4th (Rhodes character)
            unisonWidth: 0.5
        }
    };

    // ============================================================
    // VOICE LEADER
    // ============================================================

    class VoiceLeader {
        constructor() {
            this.voices = [48, 52, 55, 60]; // Bass, Tenor, Alto, Soprano (C3, E3, G3, C4)
            this.voiceRanges = {
                bass:    { min: 36, max: 60 },
                tenor:   { min: 48, max: 67 },
                alto:    { min: 55, max: 74 },
                soprano: { min: 60, max: 81 }
            };
            // Centros ideales para cada voz (registro mÃ¡s resonante)
            this.voiceCenters = {
                bass:    48,  // C3
                tenor:   52,  // E3
                alto:    64,  // E4
                soprano: 72   // C5
            };
            this.centerPenaltyWeight = 0.15; // Peso de la penalizaciÃ³n por alejarse del centro
            this.style = 'clasico';
        }

        setStyle(style) {
            this.style = style;
        }

        getVoices() {
            return [...this.voices];
        }

        transition(targetChord, inversion = 0, keyPitch = 0) {
            const chordData = CHORDS[targetChord] || CHORDS_MINOR[targetChord];
            if (!chordData) return null;
            let pitchClasses = [chordData.root, chordData.third, chordData.fifth];
            if (chordData.seventh !== undefined) pitchClasses.push(chordData.seventh);

            // Apply key transposition
            pitchClasses = pitchClasses.map(pc => (pc + keyPitch) % 12);

            const bassPC = pitchClasses[inversion % pitchClasses.length];
            const newVoicing = this.findOptimalVoicing(pitchClasses, bassPC);

            if (newVoicing) {
                const oldVoices = [...this.voices];
                this.voices = newVoicing;
                return { from: oldVoices, to: newVoicing };
            }
            return null;
        }

        findOptimalVoicing(pitchClasses, bassNote) {
            const candidates = this.generateVoicings(pitchClasses, bassNote);
            const rules = VOICE_LEADING_RULES[this.style];

            let valid = candidates;
            if (rules.strictParallels) {
                valid = candidates.filter(v => this.isValidVoiceLeading(this.voices, v));
            }

            if (valid.length === 0) valid = candidates;
            if (valid.length === 0) return null;

            const centers = [
                this.voiceCenters.bass,
                this.voiceCenters.tenor,
                this.voiceCenters.alto,
                this.voiceCenters.soprano
            ];

            return valid.reduce((best, candidate) => {
                // Costo por movimiento de voces (voice leading)
                const movementCost = this.totalVoiceDistance(this.voices, candidate);

                // Costo por alejarse del centro ideal (mantiene voces en registro resonante)
                const centerCost = candidate.reduce((sum, note, i) => {
                    return sum + Math.abs(note - centers[i]);
                }, 0);

                // Costo total: movimiento + penalizaciÃ³n por alejarse del centro
                const totalCost = movementCost + (centerCost * this.centerPenaltyWeight);

                return totalCost < best.cost ? { voicing: candidate, cost: totalCost } : best;
            }, { voicing: null, cost: Infinity }).voicing;
        }

        generateVoicings(pitchClasses, bassNote) {
            const voicings = [];
            const bassOptions = this.getNotesInRange(bassNote, this.voiceRanges.bass);

            for (const b of bassOptions.slice(0, 2)) {
                const remaining = pitchClasses.filter(p => p !== bassNote % 12);
                const upperPCs = [...remaining, ...pitchClasses];

                const tenorOptions = this.getNotesInRange(upperPCs, this.voiceRanges.tenor).slice(0, 4);
                const altoOptions = this.getNotesInRange(upperPCs, this.voiceRanges.alto).slice(0, 4);
                const sopranoOptions = this.getNotesInRange(pitchClasses, this.voiceRanges.soprano).slice(0, 4);

                for (const t of tenorOptions) {
                    for (const a of altoOptions) {
                        for (const s of sopranoOptions) {
                            if (b < t && t <= a && a <= s) {
                                voicings.push([b, t, a, s]);
                            }
                        }
                    }
                }
            }

            return voicings;
        }

        getNotesInRange(pitchClassOrArray, range) {
            const pcs = Array.isArray(pitchClassOrArray) ? pitchClassOrArray : [pitchClassOrArray];
            const notes = [];

            for (const pc of pcs) {
                for (let octave = 0; octave < 8; octave++) {
                    const note = pc + octave * 12;
                    if (note >= range.min && note <= range.max) {
                        notes.push(note);
                    }
                }
            }

            return [...new Set(notes)].sort((a, b) => a - b);
        }

        totalVoiceDistance(from, to) {
            return from.reduce((sum, note, i) => sum + Math.abs(note - to[i]), 0);
        }

        isValidVoiceLeading(from, to) {
            // Avoid parallel fifths and octaves
            for (let i = 0; i < from.length - 1; i++) {
                for (let j = i + 1; j < from.length; j++) {
                    const interval1 = Math.abs(from[i] - from[j]) % 12;
                    const interval2 = Math.abs(to[i] - to[j]) % 12;

                    if ((interval1 === 7 && interval2 === 7) || (interval1 === 0 && interval2 === 0)) {
                        const dir1 = Math.sign(to[i] - from[i]);
                        const dir2 = Math.sign(to[j] - from[j]);
                        if (dir1 === dir2 && dir1 !== 0) return false;
                    }
                }
            }

            // Check voice crossing
            if (to[0] >= to[1] || to[1] > to[2] || to[2] > to[3]) {
                return false;
            }

            return true;
        }
    }

    // ============================================================
    // TONAL GRAVITY (Harmonic State Machine)
    // ============================================================

    // Matriz de transiciones "estrictas" (gravedad alta)
    const STRICT_TRANSITIONS = {
        'I':    { 'I': 0.02, 'ii': 0.15, 'iii': 0.03, 'IV': 0.35, 'V': 0.35, 'vi': 0.08, 'viio': 0.02 },
        'ii':   { 'I': 0.02, 'ii': 0.02, 'iii': 0.01, 'IV': 0.05, 'V': 0.75, 'vi': 0.03, 'viio': 0.12 },
        'iii':  { 'I': 0.05, 'ii': 0.05, 'iii': 0.02, 'IV': 0.35, 'V': 0.08, 'vi': 0.43, 'viio': 0.02 },
        'IV':   { 'I': 0.10, 'ii': 0.08, 'iii': 0.02, 'IV': 0.02, 'V': 0.65, 'vi': 0.03, 'viio': 0.10 },
        'V':    { 'I': 0.82, 'ii': 0.01, 'iii': 0.01, 'IV': 0.02, 'V': 0.02, 'vi': 0.10, 'viio': 0.02 },
        'vi':   { 'I': 0.05, 'ii': 0.30, 'iii': 0.03, 'IV': 0.40, 'V': 0.15, 'vi': 0.02, 'viio': 0.05 },
        'viio': { 'I': 0.88, 'ii': 0.01, 'iii': 0.03, 'IV': 0.01, 'V': 0.02, 'vi': 0.03, 'viio': 0.02 }
    };

    // DistribuciÃ³n uniforme (gravedad = 0, caos total)
    const UNIFORM_PROB = 1 / 7;

    class TonalGravity {
        constructor() {
            this.position = 'I';
            this.inversion = 0;
            this.tension = 0;
            this.history = ['I'];
            this.bassHistory = [0];
            this.bassDirection = 0;
            this.key = 'C';
            this.keyPitch = 0;
            this.mode = 'major';

            // Bias sliders
            this.gravity = 0.5;        // 0 = caos, 1 = estricto
            this.chaosNoise = 0;       // Ruido temporal inyectado
            this.chaosDecayRate = 0.7; // Decae 30% por acorde

            // ModulaciÃ³n automÃ¡tica
            this.modulationEnabled = false;
            this.chordsSinceModulation = 0;
            this.modulationThreshold = 10;      // MÃ­nimo acordes antes de modular
            this.modulationProbability = 0.15;  // Probabilidad base por acorde (despuÃ©s del threshold)
        }

        setMode(mode) {
            this.mode = mode;
            // Resetear a la tÃ³nica del nuevo modo
            const tonic = mode === 'minor' ? 'i' : 'I';
            this.position = tonic;
            this.history = [tonic];
            this.tension = 0;
        }

        getChords() {
            return this.mode === 'minor' ? CHORDS_MINOR : CHORDS;
        }

        getTransitions() {
            return this.mode === 'minor' ? TRANSITIONS_MINOR : DETAILED_TRANSITIONS;
        }

        getTonic() {
            return this.mode === 'minor' ? 'i' : 'I';
        }

        setKey(keyName) {
            this.key = keyName;
            this.keyPitch = KEY_PITCHES[keyName] || 0;
        }

        setGravity(value) {
            this.gravity = Math.max(0, Math.min(1, value));
        }

        injectChaos(amount = 0.4) {
            this.chaosNoise = Math.min(1, this.chaosNoise + amount);
        }

        decayChaos() {
            this.chaosNoise *= this.chaosDecayRate;
            if (this.chaosNoise < 0.01) this.chaosNoise = 0;
        }

        getTransitionProbabilities() {
            const transitions = this.getTransitions();
            const chordsDict = this.getChords();
            const base = transitions[this.position];
            // Para modo menor usamos base como strict tambiÃ©n (simplificaciÃ³n)
            const strict = this.mode === 'minor' ? base : STRICT_TRANSITIONS[this.position];
            const modified = {};
            let total = 0;

            const chords = Object.keys(base);

            for (const target of chords) {
                const targetData = chordsDict[target];

                // Interpolar entre uniforme, base y estricta segÃºn gravedad
                // gravedad 0 â†’ uniforme
                // gravedad 0.5 â†’ base (comportamiento original)
                // gravedad 1 â†’ estricta
                let p;
                if (this.gravity <= 0.5) {
                    // Entre uniforme y base
                    const t = this.gravity * 2; // 0â†’0, 0.5â†’1
                    p = UNIFORM_PROB * (1 - t) + base[target] * t;
                } else {
                    // Entre base y estricta
                    const t = (this.gravity - 0.5) * 2; // 0.5â†’0, 1â†’1
                    p = base[target] * (1 - t) + strict[target] * t;
                }

                // ModificaciÃ³n por tensiÃ³n (escalada por gravedad)
                const tensionEffect = this.gravity; // A mÃ¡s gravedad, mÃ¡s efecto de tensiÃ³n
                if (this.tension > 0.7 && targetData.function === 'T') {
                    p *= (1 + this.tension * tensionEffect);
                } else if (this.tension < 0.3 && targetData.function === 'D') {
                    p *= (1 + (0.5 - this.tension) * tensionEffect);
                }

                // AÃ±adir ruido de caos (si hay)
                if (this.chaosNoise > 0) {
                    const noise = (Math.random() - 0.5) * this.chaosNoise * 0.5;
                    p = Math.max(0.01, p + noise);
                }

                modified[target] = p;
                total += p;
            }

            // Normalizar
            for (const key of Object.keys(modified)) {
                modified[key] /= total;
            }

            return modified;
        }

        // Obtener matriz completa para visualizaciÃ³n
        getFullMatrix() {
            const matrix = {};
            const originalPosition = this.position;

            for (const from of Object.keys(DETAILED_TRANSITIONS)) {
                this.position = from;
                matrix[from] = this.getTransitionProbabilities();
            }

            this.position = originalPosition;
            return matrix;
        }

        // Calcular entropÃ­a (medida de predictibilidad)
        getEntropy() {
            const probs = this.getTransitionProbabilities();
            let entropy = 0;
            for (const p of Object.values(probs)) {
                if (p > 0) {
                    entropy -= p * Math.log2(p);
                }
            }
            // Normalizar: max entropy = log2(7) â‰ˆ 2.807
            return entropy / Math.log2(7);
        }

        // Actualizar tensiÃ³n segÃºn funciÃ³n del acorde (afectada por gravedad)
        updateTensionForChord(chordData) {
            // A mÃ¡s gravedad, mÃ¡s rÃ¡pido se resuelve/acumula la tensiÃ³n
            const gravityFactor = 0.5 + this.gravity * 0.5; // 0.5 a 1.0

            if (chordData.function === 'T') {
                // ResoluciÃ³n: mÃ¡s rÃ¡pida con alta gravedad
                const decayRate = 0.2 + (0.3 * gravityFactor); // 0.35 a 0.5
                this.tension *= (1 - decayRate);
            } else if (chordData.function === 'D') {
                // AcumulaciÃ³n: mÃ¡s fuerte con alta gravedad
                const buildRate = 0.2 + (0.2 * gravityFactor); // 0.3 a 0.4
                this.tension = Math.min(1, this.tension + buildRate);
            } else {
                // S: acumulaciÃ³n moderada
                const buildRate = 0.05 + (0.1 * gravityFactor); // 0.1 a 0.15
                this.tension = Math.min(1, this.tension + buildRate);
            }
        }

        step() {
            const probs = this.getTransitionProbabilities();
            const nextChord = this.weightedRandom(probs);

            // Choose bass note with inertia
            const currentBass = this.bassHistory[this.bassHistory.length - 1];
            const bassChoice = this.chooseBassNote(nextChord, currentBass);
            this.inversion = bassChoice.inversion;

            // Update bass history
            this.bassHistory.push(bassChoice.bass);
            if (this.bassHistory.length > 16) this.bassHistory.shift();

            // Update tension (afectada por gravedad)
            this.updateTensionForChord(this.getChords()[nextChord]);

            // Decay del caos
            this.decayChaos();

            // Update history
            this.history.push(nextChord);
            if (this.history.length > 16) this.history.shift();

            this.position = nextChord;

            return {
                chord: nextChord,
                inversion: this.inversion,
                tension: this.tension,
                bass: bassChoice.bass,
                entropy: this.getEntropy(),
                chaosLevel: this.chaosNoise
            };
        }

        goTo(chord) {
            // For guided mode - force transition to specific chord
            const currentBass = this.bassHistory[this.bassHistory.length - 1];
            const bassChoice = this.chooseBassNote(chord, currentBass);
            this.inversion = bassChoice.inversion;

            this.bassHistory.push(bassChoice.bass);
            if (this.bassHistory.length > 16) this.bassHistory.shift();

            // Update tension (afectada por gravedad)
            this.updateTensionForChord(this.getChords()[chord]);

            // Decay del caos
            this.decayChaos();

            this.history.push(chord);
            if (this.history.length > 16) this.history.shift();

            this.position = chord;

            return {
                chord,
                inversion: this.inversion,
                tension: this.tension,
                bass: bassChoice.bass
            };
        }

        chooseBassNote(nextChord, currentBass) {
            const chord = this.getChords()[nextChord];
            if (!chord) return { bass: 0, inversion: 0 };
            const candidates = [
                { bass: chord.root, inversion: 0 },
                { bass: chord.third, inversion: 1 },
                { bass: chord.fifth, inversion: 2 }
            ];

            candidates.forEach(c => {
                const distance = this.minDistance(currentBass, c.bass);
                const direction = Math.sign(c.bass - currentBass);

                c.score = 10 - distance;

                if (direction === this.bassDirection && this.bassDirection !== 0) {
                    c.score += 2;
                }

                if (distance <= 2) c.score += 2;
                if (c.inversion === 0) c.score += 1; // Prefer root position slightly
            });

            const best = candidates.reduce((a, b) => a.score > b.score ? a : b);
            this.bassDirection = Math.sign(best.bass - currentBass);

            return best;
        }

        minDistance(a, b) {
            a = ((a % 12) + 12) % 12;
            b = ((b % 12) + 12) % 12;
            return Math.min(
                Math.abs(a - b),
                Math.abs(a - (b + 12)),
                Math.abs(a - (b - 12))
            );
        }

        weightedRandom(probs) {
            const r = Math.random();
            let cumulative = 0;
            for (const [key, prob] of Object.entries(probs)) {
                cumulative += prob;
                if (r < cumulative) return key;
            }
            return Object.keys(probs)[0];
        }

        reset() {
            this.position = 'I';
            this.inversion = 0;
            this.tension = 0;
            this.history = ['I'];
            this.bassHistory = [0];
            this.bassDirection = 0;
            this.chaosNoise = 0; // Reset del caos
        }

        detectCadence() {
            if (this.history.length < 2) return null;
            const last2 = this.history.slice(-2);

            for (const [name, cadence] of Object.entries(CADENCES)) {
                const [p1, p2] = cadence.pattern;
                if ((p1 === '*' || p1 === last2[0]) && p2 === last2[1]) {
                    return { type: name, ...cadence };
                }
            }
            return null;
        }

        // ==================== MODULACIÃ“N ====================

        setModulationEnabled(enabled) {
            this.modulationEnabled = enabled;
            if (enabled) {
                this.chordsSinceModulation = 0;
            }
        }

        // Tonalidades cercanas en el cÃ­rculo de quintas
        getRelatedKeys() {
            const circleOfFifths = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
            const currentIndex = circleOfFifths.indexOf(this.key);

            // Si no encontramos la tonalidad exacta, buscar enarmÃ³nico
            let idx = currentIndex;
            if (idx === -1) {
                // Buscar enarmÃ³nicos
                const enharmonics = { 'C#': 'Db', 'Gb': 'F#', 'D#': 'Eb', 'G#': 'Ab', 'A#': 'Bb' };
                const searchKey = enharmonics[this.key] || this.key;
                idx = circleOfFifths.indexOf(searchKey);
                if (idx === -1) idx = 0; // Fallback a C
            }

            const len = circleOfFifths.length;
            return {
                dominant: circleOfFifths[(idx + 1) % len],      // +1 quinta (ej: C â†’ G)
                subdominant: circleOfFifths[(idx - 1 + len) % len], // -1 quinta (ej: C â†’ F)
                // Relativo menor/mayor depende del modo actual
                relative: this.mode === 'major'
                    ? circleOfFifths[(idx + 3) % len]  // Relativo menor estÃ¡ 3 posiciones adelante
                    : circleOfFifths[(idx - 3 + len) % len]  // Relativo mayor estÃ¡ 3 atrÃ¡s
            };
        }

        // Determinar si es buen momento para modular
        shouldModulate() {
            if (!this.modulationEnabled) return false;
            if (this.chordsSinceModulation < this.modulationThreshold) return false;

            // Solo modular desde tÃ³nica (momento de estabilidad)
            const tonic = this.getTonic();
            if (this.position !== tonic) return false;

            // Probabilidad aumenta con el tiempo sin modular
            const extraChords = this.chordsSinceModulation - this.modulationThreshold;
            const probability = this.modulationProbability + (extraChords * 0.02);

            return Math.random() < probability;
        }

        // Elegir tonalidad destino
        chooseModulationTarget() {
            const related = this.getRelatedKeys();
            const options = [
                { key: related.dominant, weight: 0.45, name: 'dominante' },
                { key: related.subdominant, weight: 0.35, name: 'subdominante' },
                { key: related.relative, weight: 0.20, name: 'relativo' }
            ];

            const r = Math.random();
            let cumulative = 0;
            for (const opt of options) {
                cumulative += opt.weight;
                if (r < cumulative) {
                    return { key: opt.key, relation: opt.name };
                }
            }
            return { key: options[0].key, relation: options[0].name };
        }

        // Forzar modulaciÃ³n manual
        forceModulation() {
            try {
                const target = this.chooseModulationTarget();
                const oldKey = this.key;
                const newKey = target.key;
                const relation = target.relation;

                // Cambiar tonalidad
                this.setKey(newKey);

                // Resetear estado
                this.position = this.getTonic();
                this.tension = 0;
                this.chordsSinceModulation = 0;

                // Resetear historial para nueva tonalidad
                this.history = [this.getTonic()];

                return {
                    type: 'complete',
                    from: oldKey,
                    to: newKey,
                    relation: relation
                };
            } catch (err) {
                console.error('Error en forceModulation:', err);
                return null;
            }
        }

        // Verificar y ejecutar modulaciÃ³n si corresponde
        checkModulation() {
            try {
                this.chordsSinceModulation++;

                // Verificar si debemos modular (estamos en tÃ³nica, pasÃ³ el threshold, etc.)
                if (!this.shouldModulate()) {
                    return null;
                }

                // Elegir tonalidad destino y modular directamente
                const target = this.chooseModulationTarget();
                const oldKey = this.key;
                const newKey = target.key;
                const relation = target.relation;

                // Cambiar tonalidad
                this.setKey(newKey);

                // Resetear estado
                this.position = this.getTonic();
                this.tension = 0;
                this.chordsSinceModulation = 0;

                // Resetear historial para nueva tonalidad
                this.history = [this.getTonic()];

                return {
                    type: 'complete',
                    from: oldKey,
                    to: newKey,
                    relation: relation
                };
            } catch (err) {
                console.error('Error en checkModulation:', err);
                return null;
            }
        }
    }

    // ============================================================
    // RHYTHMIC HARMONY
    // ============================================================

    class RhythmicHarmony {
        constructor(baseTempo = 80) {
            this.baseTempo = baseTempo;
            this.style = 'clasico';
        }

        setTempo(bpm) {
            this.baseTempo = bpm;
        }

        setStyle(style) {
            this.style = style;
        }

        computeDuration(chord, context) {
            let baseDuration = 60 / this.baseTempo;

            const functionMultipliers = {
                'T': context.isResolution ? 1.8 : 1.0,
                'S': 1.0,
                'D': context.tensionLevel > 0.7 ? 0.8 : 0.95
            };

            const chordData = CHORDS[chord] || CHORDS_MINOR[chord] || { function: 'T' };
            const chordFunction = chordData.function;
            baseDuration *= functionMultipliers[chordFunction] || 1.0;

            if (this.style === 'romantico') {
                baseDuration *= this.computeRubato(context);
            }

            return baseDuration;
        }

        computeArticulation(chord, context) {
            const chordData = CHORDS[chord] || CHORDS_MINOR[chord] || { tension: 0.5, function: 'T' };
            const tension = chordData.tension;
            const func = chordData.function;

            return {
                attackTime: tension > 0.7 ? 0.02 : 0.05,
                releaseTime: tension > 0.7 ? 0.08 : 0.15,
                decayTime: func === 'D' ? 0.1 : 0.2,
                sustainLevel: tension > 0.7 ? 0.25 : 0.20,
                velocity: 0.2 + (tension * 0.1)
            };
        }

        computeRubato(context) {
            if (context.tensionRising && context.tensionLevel > 0.5) {
                return 1.0 - (context.tensionLevel * 0.15);
            }
            if (context.approachingCadence) {
                return 1.0 + (context.cadenceProximity * 0.3);
            }
            return 1.0 + (Math.random() - 0.5) * 0.08;
        }
    }

    // ============================================================
    // BASS PATTERN GENERATOR
    // ============================================================

    class BassPatternGenerator {
        constructor() {
            this.patterns = {
                // Alberti: 1-5-3-5 (clÃ¡sico)
                alberti: (root, third, fifth) => [root, fifth, third, fifth],
                // Barroco: 1-3-5-3
                barroco: (root, third, fifth) => [root, third, fifth, third],
                // Octavas rotas: 1-8-1-8 (romÃ¡ntico)
                octaves: (root, third, fifth) => [root, root + 12, root, root + 12],
                // Walking: aproximaciÃ³n cromÃ¡tica (jazz)
                walking: (root, third, fifth, nextRoot) => {
                    // Si hay siguiente acorde, aproximar cromÃ¡ticamente
                    if (nextRoot !== undefined) {
                        const approach = nextRoot > root ? nextRoot - 1 : nextRoot + 1;
                        return [root, third, fifth, approach];
                    }
                    return [root, fifth, third, root];
                },
                // Block: nota sostenida (default)
                block: (root) => [root]
            };
        }

        generate(style, chordTones, nextRoot = undefined) {
            const [root, third, fifth] = chordTones;

            const stylePatterns = {
                'barroco': 'barroco',
                'clasico': 'alberti',
                'romantico': 'octaves',
                'jazz': 'walking'
            };

            const patternName = stylePatterns[style] || 'block';
            const pattern = this.patterns[patternName];

            return pattern(root, third, fifth, nextRoot);
        }

        getSubdivisions(style) {
            // NÃºmero de notas por pulso
            return {
                'barroco': 2,    // corcheas
                'clasico': 4,   // semicorcheas
                'romantico': 2, // corcheas
                'jazz': 1       // negras (walking bass)
            }[style] || 1;
        }
    }

    // ============================================================
    // FREEVERB - Algorithmic Reverb (Schroeder/Moorer design)
    // ============================================================

    class Freeverb {
        constructor(audioCtx) {
            this.ctx = audioCtx;
            this.input = audioCtx.createGain();
            this.output = audioCtx.createGain();
            this.wetGain = audioCtx.createGain();
            this.dryGain = audioCtx.createGain();

            // Reverb parameters
            this.roomSize = 0.7;
            this.damping = 0.5;
            this.wetLevel = 0.35;

            this.wetGain.gain.value = this.wetLevel;
            this.dryGain.gain.value = 1 - this.wetLevel;

            // Comb filter delay times (in seconds) - tuned for rich sound
            const combTunings = [1557, 1617, 1491, 1422, 1277, 1356, 1188, 1116].map(t => t / 44100);
            // Allpass filter delay times
            const allpassTunings = [556, 441, 341, 225].map(t => t / 44100);

            // Create parallel comb filters
            this.combFilters = combTunings.map(delayTime => {
                return this.createCombFilter(delayTime);
            });

            // Create series allpass filters
            this.allpassFilters = allpassTunings.map(delayTime => {
                return this.createAllpassFilter(delayTime);
            });

            // Merge node for comb outputs
            const combMerge = audioCtx.createGain();
            combMerge.gain.value = 0.25; // Scale down combined combs

            // Connect comb filters in parallel
            this.combFilters.forEach(comb => {
                this.input.connect(comb.input);
                comb.output.connect(combMerge);
            });

            // Connect allpass filters in series
            let prevNode = combMerge;
            this.allpassFilters.forEach(allpass => {
                prevNode.connect(allpass.input);
                prevNode = allpass.output;
            });

            // Final output routing
            prevNode.connect(this.wetGain);
            this.input.connect(this.dryGain);
            this.wetGain.connect(this.output);
            this.dryGain.connect(this.output);

            this.updateParameters();
        }

        createCombFilter(delayTime) {
            const delay = this.ctx.createDelay(1);
            const feedback = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();

            delay.delayTime.value = delayTime;
            filter.type = 'lowpass';
            filter.frequency.value = 5000;

            delay.connect(filter);
            filter.connect(feedback);
            feedback.connect(delay);

            return {
                input: delay,
                output: delay,
                feedback: feedback,
                filter: filter,
                delayTime: delayTime
            };
        }

        createAllpassFilter(delayTime) {
            const delay = this.ctx.createDelay(1);
            const feedback = this.ctx.createGain();
            const feedforward = this.ctx.createGain();
            const output = this.ctx.createGain();

            delay.delayTime.value = delayTime;
            feedback.gain.value = 0.5;
            feedforward.gain.value = -0.5;

            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(output);

            const input = this.ctx.createGain();
            input.connect(delay);
            input.connect(feedforward);
            feedforward.connect(output);

            return { input, output };
        }

        updateParameters() {
            const feedbackLevel = this.roomSize * 0.85 + 0.1;
            const dampFreq = (1 - this.damping) * 10000 + 1000;

            this.combFilters.forEach(comb => {
                comb.feedback.gain.value = feedbackLevel;
                comb.filter.frequency.value = dampFreq;
            });
        }

        setRoomSize(value) {
            this.roomSize = Math.max(0, Math.min(1, value));
            this.updateParameters();
        }

        setDamping(value) {
            this.damping = Math.max(0, Math.min(1, value));
            this.updateParameters();
        }

        setWetLevel(value) {
            this.wetLevel = Math.max(0, Math.min(1, value));
            this.wetGain.gain.value = this.wetLevel;
            this.dryGain.gain.value = 1 - this.wetLevel * 0.5;
        }
    }

    // ============================================================
    // AUDIO SYNTHESIZER - Professional Quality
    // ============================================================

    class VoiceLeadingSynth {
        constructor(audioCtx) {
            this.ctx = audioCtx;

            // Voice arrays - each voice has dual oscillators
            this.voices = [];     // [{osc1, osc2, gain, filter, filterEnv}]
            this.gains = [];      // Individual voice gains (for compatibility)

            // Voice control arrays: [Bajo, Tenor, Alto, Soprano]
            this.voiceMutes = [false, false, false, false];
            this.voiceVolumes = [0.8, 0.8, 0.8, 0.8];

            // Stereo panning positions: [Bajo, Tenor, Alto, Soprano]
            // Spread across stereo field: left â†’ right
            this.panPositions = [-0.5, -0.15, 0.15, 0.5];

            // Filter settings per voice register (Bajo, Tenor, Alto, Soprano)
            this.filterSettings = [
                { freq: 800,  Q: 0.7, envAmount: 400  },   // Bajo: cÃ¡lido
                { freq: 1500, Q: 0.8, envAmount: 600  },   // Tenor: medio
                { freq: 2500, Q: 0.9, envAmount: 800  },   // Alto: brillante
                { freq: 4000, Q: 1.0, envAmount: 1200 }    // Soprano: muy brillante
            ];

            // Detune amounts for unison (cents)
            this.unisonDetune = [3, 5, 7, 10]; // MÃ¡s detune en agudos

            // Master output chain
            this.masterGain = audioCtx.createGain();
            this.masterGain.gain.value = 0.25;

            // Create Freeverb
            this.reverb = new Freeverb(audioCtx);
            this.reverb.setRoomSize(0.75);
            this.reverb.setDamping(0.4);
            this.reverb.setWetLevel(0.3);

            // Soft saturation/warmth
            this.saturator = this.createSaturator();

            // Early reflections (short delays with stereo spread)
            this.earlyReflections = this.createEarlyReflections();

            // Master compressor for glue and cohesion
            this.compressor = audioCtx.createDynamicsCompressor();
            this.compressor.threshold.value = -18;  // Start compressing at -18dB
            this.compressor.knee.value = 12;        // Soft knee for musical compression
            this.compressor.ratio.value = 3;        // Gentle 3:1 ratio
            this.compressor.attack.value = 0.015;   // 15ms attack - preserve transients
            this.compressor.release.value = 0.25;   // 250ms release - smooth

            // Connect master chain:
            // masterGain â†’ saturator â†’ earlyReflections â†’ reverb â†’ compressor â†’ destination
            this.masterGain.connect(this.saturator);
            this.saturator.connect(this.earlyReflections.input);
            this.earlyReflections.output.connect(this.reverb.input);
            this.reverb.output.connect(this.compressor);
            this.compressor.connect(audioCtx.destination);

            // Create 4 voices with dual oscillators
            for (let i = 0; i < 4; i++) {
                const voice = this.createVoice(i);
                this.voices.push(voice);
                this.gains.push(voice.gain);
            }
        }

        createSaturator() {
            // Subtle waveshaper for analog warmth
            const waveshaper = this.ctx.createWaveShaper();
            const samples = 44100;
            const curve = new Float32Array(samples);

            for (let i = 0; i < samples; i++) {
                const x = (i * 2) / samples - 1;
                // Soft clipping curve
                curve[i] = Math.tanh(x * 1.2) * 0.9;
            }

            waveshaper.curve = curve;
            waveshaper.oversample = '2x';
            return waveshaper;
        }

        createEarlyReflections() {
            // Early reflections simulate first bounces off walls
            // Creates sense of space before main reverb
            const input = this.ctx.createGain();
            const output = this.ctx.createGain();
            const dryGain = this.ctx.createGain();
            dryGain.gain.value = 0.85;

            // 4 early reflection taps with different delays and panning
            const taps = [
                { delay: 0.011, pan: -0.7, gain: 0.15 },  // Left wall
                { delay: 0.019, pan: 0.7,  gain: 0.12 },  // Right wall
                { delay: 0.027, pan: -0.3, gain: 0.08 },  // Back left
                { delay: 0.037, pan: 0.3,  gain: 0.06 }   // Back right
            ];

            // Create tap chain
            taps.forEach(tap => {
                const delay = this.ctx.createDelay(0.1);
                delay.delayTime.value = tap.delay;

                const panner = this.ctx.createStereoPanner();
                panner.pan.value = tap.pan;

                const gain = this.ctx.createGain();
                gain.gain.value = tap.gain;

                // High shelf filter to darken reflections (simulates absorption)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 6000;

                input.connect(delay);
                delay.connect(filter);
                filter.connect(panner);
                panner.connect(gain);
                gain.connect(output);
            });

            // Dry path
            input.connect(dryGain);
            dryGain.connect(output);

            return { input, output };
        }

        createVoice(index) {
            const settings = this.filterSettings[index];
            const detune = this.unisonDetune[index];

            // Vibrato settings per voice (mÃ¡s en agudos)
            const vibratoSettings = [
                { rate: 4.5, depth: 8 },   // Bajo: sutil
                { rate: 5.0, depth: 12 },  // Tenor
                { rate: 5.5, depth: 18 },  // Alto
                { rate: 6.0, depth: 25 }   // Soprano: expresivo
            ][index];

            // Dual oscillators for unison/chorus effect
            const osc1 = this.ctx.createOscillator();
            const osc2 = this.ctx.createOscillator();

            // Detune osc2 for chorus effect
            osc1.detune.value = -detune / 2;
            osc2.detune.value = detune / 2;

            // LFO for vibrato
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            lfo.type = 'sine';
            lfo.frequency.value = vibratoSettings.rate;
            lfoGain.gain.value = 0; // Starts silent, activated on long notes

            // Connect LFO to both oscillators' detune
            lfo.connect(lfoGain);
            lfoGain.connect(osc1.detune);
            lfoGain.connect(osc2.detune);
            lfo.start();

            // Individual osc gains for mixing
            const osc1Gain = this.ctx.createGain();
            const osc2Gain = this.ctx.createGain();
            osc1Gain.gain.value = 0.6;
            osc2Gain.gain.value = 0.4;

            // Merge oscillators
            const oscMerge = this.ctx.createGain();
            osc1.connect(osc1Gain);
            osc2.connect(osc2Gain);
            osc1Gain.connect(oscMerge);
            osc2Gain.connect(oscMerge);

            // Filter with resonance
            const filter = this.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = settings.freq;
            filter.Q.value = settings.Q;

            // Voice output gain
            const gain = this.ctx.createGain();
            gain.gain.value = 0;

            // Stereo panner for spatial positioning
            const panner = this.ctx.createStereoPanner();
            panner.pan.value = this.panPositions[index];

            // Connect voice chain: oscs â†’ filter â†’ gain â†’ panner â†’ master
            oscMerge.connect(filter);
            filter.connect(gain);
            gain.connect(panner);
            panner.connect(this.masterGain);

            // Start oscillators
            osc1.start();
            osc2.start();

            return {
                osc1, osc2,
                osc1Gain, osc2Gain,
                lfo, lfoGain,
                vibratoDepth: vibratoSettings.depth,
                baseVibratoDepth: vibratoSettings.depth,
                filter,
                gain,
                panner,
                settings,
                baseDetune: detune
            };
        }

        transitionTo(newVoicing, duration, articulation, bassPattern = null) {
            const now = this.ctx.currentTime;
            const glideTime = Math.min(duration * 0.3, 0.08);

            // Micro-timing offsets (humanizaciÃ³n - voces no atacan exactamente juntas)
            const microTimingRange = 0.012; // hasta 12ms de variaciÃ³n
            const offsets = [0, 1, 2, 3].map(() => Math.random() * microTimingRange);

            // Voces superiores (Tenor, Alto, Soprano) - Ã­ndices 1, 2, 3
            for (let i = 1; i < newVoicing.length; i++) {
                const voice = this.voices[i];
                const freq = this.midiToFreq(newVoicing[i]);
                const offset = offsets[i]; // Micro-timing offset

                // Dual oscillators - ambos siguen la frecuencia
                voice.osc1.frequency.linearRampToValueAtTime(freq, now + offset + glideTime);
                voice.osc2.frequency.linearRampToValueAtTime(freq, now + offset + glideTime);

                // HumanizaciÃ³n: variaciÃ³n sutil del detune
                const baseDetune = voice.baseDetune;
                const variation = (Math.random() - 0.5) * 4;
                voice.osc1.detune.linearRampToValueAtTime(-baseDetune / 2 + variation, now + offset + glideTime);
                voice.osc2.detune.linearRampToValueAtTime(baseDetune / 2 + variation, now + offset + glideTime);

                // Vibrato: entra gradualmente despuÃ©s del ataque
                const vibratoDelay = Math.min(duration * 0.3, 0.15); // Espera antes de vibrato
                const vibratoRampTime = duration * 0.2;
                voice.lfoGain.gain.cancelScheduledValues(now);
                voice.lfoGain.gain.setValueAtTime(0, now + offset);
                voice.lfoGain.gain.setValueAtTime(0, now + offset + vibratoDelay);
                voice.lfoGain.gain.linearRampToValueAtTime(voice.vibratoDepth, now + offset + vibratoDelay + vibratoRampTime);
                // Fade out vibrato antes del release
                voice.lfoGain.gain.setValueAtTime(voice.vibratoDepth, now + duration - articulation.releaseTime * 1.5);
                voice.lfoGain.gain.linearRampToValueAtTime(0, now + duration);

                // Filter envelope - brillo en el ataque, decae suavemente
                const filter = voice.filter;
                const settings = voice.settings;
                filter.frequency.cancelScheduledValues(now);
                filter.frequency.setValueAtTime(settings.freq * 0.8, now + offset);
                filter.frequency.linearRampToValueAtTime(settings.freq + settings.envAmount, now + offset + articulation.attackTime);
                filter.frequency.exponentialRampToValueAtTime(settings.freq, now + offset + articulation.attackTime + articulation.decayTime * 3);

                // Aplicar mute y volumen individual
                const volumeMultiplier = this.voiceMutes[i] ? 0 : this.voiceVolumes[i];
                const velocity = articulation.velocity * volumeMultiplier;
                const sustain = articulation.sustainLevel * volumeMultiplier;

                const gain = voice.gain;
                gain.gain.cancelScheduledValues(now);
                gain.gain.setValueAtTime(0.01, now + offset);
                gain.gain.linearRampToValueAtTime(velocity, now + offset + articulation.attackTime);
                gain.gain.linearRampToValueAtTime(sustain, now + offset + articulation.attackTime + articulation.decayTime);
                gain.gain.setValueAtTime(sustain, now + duration - articulation.releaseTime);
                gain.gain.linearRampToValueAtTime(0.01, now + duration);
            }

            // Bajo - con patrÃ³n si se proporciona
            if (bassPattern && bassPattern.length > 1) {
                this.playBassPattern(bassPattern, duration, articulation);
            } else {
                this.playBassNote(newVoicing[0], duration, articulation, offsets[0]);
            }
        }

        playBassNote(midiNote, duration, articulation, offset = 0) {
            const now = this.ctx.currentTime;
            const glideTime = 0.06;
            const voice = this.voices[0];
            const freq = this.midiToFreq(midiNote);

            // Dual oscillators
            voice.osc1.frequency.linearRampToValueAtTime(freq, now + offset + glideTime);
            voice.osc2.frequency.linearRampToValueAtTime(freq, now + offset + glideTime);

            // Vibrato sutil para bajo (solo en notas largas)
            const vibratoDelay = Math.min(duration * 0.4, 0.2);
            voice.lfoGain.gain.cancelScheduledValues(now);
            voice.lfoGain.gain.setValueAtTime(0, now + offset);
            voice.lfoGain.gain.setValueAtTime(0, now + offset + vibratoDelay);
            voice.lfoGain.gain.linearRampToValueAtTime(voice.vibratoDepth * 0.5, now + offset + vibratoDelay + duration * 0.15);
            voice.lfoGain.gain.linearRampToValueAtTime(0, now + duration);

            // Filter envelope para bajo
            const filter = voice.filter;
            const settings = voice.settings;
            filter.frequency.cancelScheduledValues(now);
            filter.frequency.setValueAtTime(settings.freq * 0.7, now + offset);
            filter.frequency.linearRampToValueAtTime(settings.freq + settings.envAmount * 0.5, now + offset + articulation.attackTime);
            filter.frequency.exponentialRampToValueAtTime(settings.freq, now + offset + articulation.attackTime + articulation.decayTime * 2);

            // Aplicar mute y volumen
            const volumeMultiplier = this.voiceMutes[0] ? 0 : this.voiceVolumes[0];
            const velocity = articulation.velocity * volumeMultiplier;
            const sustain = articulation.sustainLevel * volumeMultiplier;

            const gain = voice.gain;
            gain.gain.cancelScheduledValues(now);
            gain.gain.setValueAtTime(0.01, now + offset);
            gain.gain.linearRampToValueAtTime(velocity, now + offset + articulation.attackTime);
            gain.gain.linearRampToValueAtTime(sustain, now + offset + articulation.attackTime + articulation.decayTime);
            gain.gain.setValueAtTime(sustain, now + duration - articulation.releaseTime);
            gain.gain.linearRampToValueAtTime(0.01, now + duration);
        }

        playBassPattern(pattern, totalDuration, articulation) {
            const now = this.ctx.currentTime;
            const noteDuration = totalDuration / pattern.length;
            const voice = this.voices[0];
            const volumeMultiplier = this.voiceMutes[0] ? 0 : this.voiceVolumes[0];

            // Cancelar eventos previos
            voice.gain.gain.cancelScheduledValues(now);
            voice.osc1.frequency.cancelScheduledValues(now);
            voice.osc2.frequency.cancelScheduledValues(now);

            pattern.forEach((note, i) => {
                const noteStart = now + (i * noteDuration);
                const freq = this.midiToFreq(note);

                // Ambos osciladores
                voice.osc1.frequency.setValueAtTime(freq, noteStart);
                voice.osc2.frequency.setValueAtTime(freq, noteStart);

                // Envolvente para cada nota
                const attackTime = Math.min(0.015, noteDuration * 0.1);
                const releaseTime = Math.min(0.025, noteDuration * 0.15);

                const vel = articulation.velocity * 0.8 * volumeMultiplier;
                voice.gain.gain.setValueAtTime(0.02, noteStart);
                voice.gain.gain.linearRampToValueAtTime(vel, noteStart + attackTime);
                voice.gain.gain.setValueAtTime(vel * 0.75, noteStart + noteDuration - releaseTime);
                voice.gain.gain.linearRampToValueAtTime(0.02, noteStart + noteDuration);
            });
        }

        setVoiceVolume(voiceIndex, value) {
            if (voiceIndex >= 0 && voiceIndex < 4) {
                this.voiceVolumes[voiceIndex] = Math.max(0, Math.min(1, value));
            }
        }

        toggleMute(voiceIndex) {
            if (voiceIndex >= 0 && voiceIndex < 4) {
                this.voiceMutes[voiceIndex] = !this.voiceMutes[voiceIndex];
                return this.voiceMutes[voiceIndex];
            }
            return false;
        }

        setMute(voiceIndex, muted) {
            if (voiceIndex >= 0 && voiceIndex < 4) {
                this.voiceMutes[voiceIndex] = muted;
            }
        }

        midiToFreq(midi) {
            return 440 * Math.pow(2, (midi - 69) / 12);
        }

        setWaveform(type) {
            this.voices.forEach(voice => {
                voice.osc1.type = type;
                voice.osc2.type = type;
            });
        }

        applyStyle(styleName) {
            const style = STYLES[styleName];
            if (!style) return;

            this.currentStyle = styleName;

            // Waveform
            this.setWaveform(style.waveform);

            // Reverb
            this.reverb.setWetLevel(style.reverbMix);
            this.reverb.setRoomSize(style.reverbSize);

            // Por cada voz, ajustar parÃ¡metros
            this.voices.forEach((voice, i) => {
                // Ajustar filtro base
                const baseFreq = this.filterSettings[i].freq;
                voice.filter.frequency.value = baseFreq * style.filterMult;

                // Ajustar vibrato depth
                voice.vibratoDepth = voice.baseVibratoDepth * style.vibratoMult;

                // Ajustar unison width (detune entre osc1 y osc2)
                const baseDetune = this.unisonDetune[i];
                const newDetune = baseDetune * style.unisonWidth;
                voice.osc1.detune.value = -newDetune / 2;
                voice.osc2.detune.value = newDetune / 2;

                // Ajustar mezcla de osciladores segÃºn armÃ³nicos del estilo
                if (style.harmonics) {
                    // osc1 = fundamental, osc2 = segundo armÃ³nico (o refuerzo)
                    const h = style.harmonics;
                    voice.osc1Gain.gain.value = 0.5 * (h[0] || 1);
                    voice.osc2Gain.gain.value = 0.5 * (h[1] || 0.3);
                }
            });

            // Guardar multiplicadores para uso en transitionTo
            this.styleParams = {
                filterMult: style.filterMult,
                vibratoMult: style.vibratoMult,
                attackMult: style.attackMult
            };
        }

        getStyleParams() {
            return this.styleParams || { filterMult: 1, vibratoMult: 1, attackMult: 1 };
        }

        setReverbMix(value) {
            this.reverb.setWetLevel(value);
        }

        setReverbSize(value) {
            this.reverb.setRoomSize(value);
        }

        // === Controles de usuario ===

        setMasterVolume(value) {
            // value: 0-100
            const gain = (value / 100) * 0.4; // Max 0.4 para no saturar
            this.masterGain.gain.linearRampToValueAtTime(gain, this.ctx.currentTime + 0.05);
        }

        setFilterBrightness(value) {
            // value: 0-100, ajusta los filtros de todas las voces
            const mult = 0.3 + (value / 100) * 1.4; // 0.3x a 1.7x del base
            this.voices.forEach((voice, i) => {
                const baseFreq = this.filterSettings[i].freq;
                voice.filter.frequency.linearRampToValueAtTime(
                    baseFreq * mult,
                    this.ctx.currentTime + 0.1
                );
            });
        }

        setDetuneAmount(value) {
            // value: 0-100
            const mult = value / 50; // 0x a 2x del detune base
            this.voices.forEach((voice, i) => {
                const baseDetune = this.unisonDetune[i];
                voice.osc1.detune.linearRampToValueAtTime(-baseDetune * mult / 2, this.ctx.currentTime + 0.1);
                voice.osc2.detune.linearRampToValueAtTime(baseDetune * mult / 2, this.ctx.currentTime + 0.1);
            });
        }

        setVibratoDepth(value) {
            // value: 0-100
            const depth = (value / 100) * 12; // 0 a 12 cents max
            this.voices.forEach(voice => {
                if (voice.vibrato) {
                    voice.vibrato.depth = depth;
                    voice.vibratoGain.gain.value = depth;
                }
            });
        }

        setAttack(value) {
            // value: 0-100, multiplier para attack
            this.attackMultiplier = 0.2 + (value / 100) * 1.8; // 0.2x a 2x
        }

        setRelease(value) {
            // value: 0-100, multiplier para release
            this.releaseMultiplier = 0.3 + (value / 100) * 2.7; // 0.3x a 3x
        }

        stop() {
            const now = this.ctx.currentTime;
            this.voices.forEach(voice => {
                voice.gain.gain.cancelScheduledValues(now);
                voice.gain.gain.linearRampToValueAtTime(0, now + 0.15);
            });
        }
    }

    // ============================================================
    // D3 VISUALIZATION
    // ============================================================

    class TonalForceField {
        constructor(svg, width, height) {
            this.svg = svg;
            this.width = width;
            this.height = height;
            this.cx = width / 2;
            this.cy = height / 2;
            this.tension = 0;
            this.activeChord = 'I';
            this.trail = [];
            this.onChordClick = null;
            this.mode = 'major';

            // Radios de los anillos funcionales
            const minDim = Math.min(width, height);
            this.functionRadii = {
                'T': minDim * 0.12,   // Anillo T* para vi, iii (I va al centro)
                'D': minDim * 0.22,   // Anillo dominante
                'S': minDim * 0.34    // Anillo subdominante (exterior)
            };

            // Ãngulos de los acordes MAYOR
            this.chordAnglesMajor = {
                'I':    0,              // Centro (ignorado, va a cx,cy)
                'vi':   Math.PI,        // Izquierda (9 o'clock)
                'iii':  0,              // Derecha (3 o'clock)
                'V':    Math.PI * 0.5,  // Abajo-derecha
                'viio': Math.PI * 0.75, // Abajo
                'ii':   Math.PI * 1.25, // Arriba-izquierda
                'IV':   Math.PI * 1.5   // Arriba
            };

            // Ãngulos de los acordes MENOR
            this.chordAnglesMinor = {
                'i':    0,              // Centro (ignorado, va a cx,cy)
                'VI':   Math.PI,        // Izquierda
                'III':  0,              // Derecha
                'V':    Math.PI * 0.5,  // Abajo-derecha
                'viio': Math.PI * 0.75, // Abajo
                'iio':  Math.PI * 1.25, // Arriba-izquierda
                'iv':   Math.PI * 1.5   // Arriba
            };

            this.chordAngles = this.chordAnglesMajor;

            this.nodesMajor = [
                { id: 'I', function: 'T' },
                { id: 'ii', function: 'S' },
                { id: 'iii', function: 'T' },
                { id: 'IV', function: 'S' },
                { id: 'V', function: 'D' },
                { id: 'vi', function: 'T' },
                { id: 'viio', function: 'D' }
            ];

            this.nodesMinor = [
                { id: 'i', function: 'T' },
                { id: 'iio', function: 'S' },
                { id: 'III', function: 'T' },
                { id: 'iv', function: 'S' },
                { id: 'V', function: 'D' },
                { id: 'VI', function: 'T' },
                { id: 'viio', function: 'D' }
            ];

            this.nodes = this.nodesMajor;

            this.initPositions();
            this.setupVisualization();
        }

        setMode(mode) {
            this.mode = mode;
            this.nodes = mode === 'minor' ? this.nodesMinor : this.nodesMajor;
            this.chordAngles = mode === 'minor' ? this.chordAnglesMinor : this.chordAnglesMajor;
            this.trail = []; // Limpiar trail al cambiar modo

            // Reinicializar posiciones y redibujar
            this.initPositions();
            d3.select(this.svg).selectAll('*').remove();
            this.setupVisualization();
        }

        getChordData(chordId) {
            const dict = this.mode === 'minor' ? CHORDS_MINOR : CHORDS;
            return dict[chordId];
        }

        getTransitions() {
            return this.mode === 'minor' ? TRANSITIONS_MINOR : DETAILED_TRANSITIONS;
        }

        getTonic() {
            return this.mode === 'minor' ? 'i' : 'I';
        }

        initPositions() {
            const chordsDict = this.mode === 'minor' ? CHORDS_MINOR : CHORDS;
            const tonic = this.mode === 'minor' ? 'i' : 'I';

            this.nodes.forEach(node => {
                if (node.id === tonic) {
                    node.x = this.cx;
                    node.y = this.cy;
                    node.fx = this.cx;
                    node.fy = this.cy;
                } else {
                    const angle = this.chordAngles[node.id];
                    const chordData = chordsDict[node.id];
                    const radius = this.functionRadii[chordData ? chordData.function : node.function];
                    node.x = this.cx + radius * Math.cos(angle);
                    node.y = this.cy + radius * Math.sin(angle);
                }
            });
        }

        setupVisualization() {
            const svg = d3.select(this.svg);
            svg.selectAll('*').remove();

            // Background gradient
            const defs = svg.append('defs');
            const radialGradient = defs.append('radialGradient')
                .attr('id', 'bgGradient')
                .attr('cx', '50%').attr('cy', '50%')
                .attr('r', '50%');
            radialGradient.append('stop').attr('offset', '0%').attr('stop-color', '#1a1a2e');
            radialGradient.append('stop').attr('offset', '100%').attr('stop-color', '#0a0a0f');

            svg.append('rect')
                .attr('width', '100%')
                .attr('height', '100%')
                .attr('fill', 'url(#bgGradient)');

            // Function zone rings
            this.drawFunctionZones(svg);

            // Trail layer
            this.trailGroup = svg.append('g').attr('class', 'trail-layer');

            // Transition arcs (probability lines)
            this.arcGroup = svg.append('g').attr('class', 'arc-layer');

            // Nodes
            this.nodeGroup = svg.append('g').attr('class', 'node-layer');

            // Create nodes
            const self = this;
            this.nodeElements = this.nodeGroup.selectAll('.chord-node')
                .data(this.nodes)
                .enter()
                .append('g')
                .attr('class', 'chord-node')
                .attr('transform', d => `translate(${d.x}, ${d.y})`)
                .on('click', function(event, d) {
                    if (self.onChordClick) {
                        self.onChordClick(d.id);
                    }
                });

            // Hit area invisible (mÃ¡s grande, captura eventos)
            this.nodeElements.append('circle')
                .attr('class', 'hit-area')
                .attr('r', d => d.id === 'I' ? 45 : 38)
                .attr('fill', 'transparent')
                .attr('stroke', 'none')
                .style('cursor', 'pointer');

            // Node circles visibles (pueden animar sin afectar hit area)
            const tonic = this.getTonic();
            this.nodeElements.append('circle')
                .attr('class', 'node-visual')
                .attr('r', d => d.id === tonic ? 32 : 24)
                .attr('fill', d => {
                    const func = this.getChordData(d.id)?.function || d.function;
                    return FUNCTION_COLORS[func];
                })
                .attr('fill-opacity', 0.2)
                .attr('stroke', d => FUNCTION_COLORS[this.getChordData(d.id)?.function || d.function])
                .attr('stroke-width', 2)
                .style('pointer-events', 'none');  // El visual no captura eventos

            // Node labels
            this.nodeElements.append('text')
                .attr('text-anchor', 'middle')
                .attr('dy', '0.35em')
                .attr('fill', '#fff')
                .attr('font-size', d => d.id === tonic ? '16px' : '14px')
                .attr('font-weight', '500')
                .text(d => d.id);

            // Glow filter
            const filter = defs.append('filter')
                .attr('id', 'glow')
                .attr('x', '-50%').attr('y', '-50%')
                .attr('width', '200%').attr('height', '200%');
            filter.append('feGaussianBlur')
                .attr('stdDeviation', '4')
                .attr('result', 'coloredBlur');
            const feMerge = filter.append('feMerge');
            feMerge.append('feMergeNode').attr('in', 'coloredBlur');
            feMerge.append('feMergeNode').attr('in', 'SourceGraphic');

            // Narrador - texto explicativo en el centro
            this.narratorText = svg.append('text')
                .attr('class', 'narrator')
                .attr('x', this.cx)
                .attr('y', this.cy + 55)
                .attr('text-anchor', 'middle')
                .attr('fill', '#94a3b8')
                .attr('font-size', '11px')
                .attr('font-style', 'italic')
                .attr('opacity', 0.9)
                .text('');

            // Guardar historial para detectar transiciones
            this.lastChord = null;

            // Initial state
            this.setActiveChord('I', 0);
        }

        drawFunctionZones(svg) {
            const zones = svg.append('g').attr('class', 'function-zones');

            // Subdominante ring (outer)
            zones.append('circle')
                .attr('cx', this.cx)
                .attr('cy', this.cy)
                .attr('r', this.functionRadii['S'])
                .attr('fill', 'none')
                .attr('stroke', FUNCTION_COLORS['S'])
                .attr('stroke-width', 40)
                .attr('stroke-opacity', 0.08);

            // Dominante ring (middle)
            zones.append('circle')
                .attr('cx', this.cx)
                .attr('cy', this.cy)
                .attr('r', this.functionRadii['D'])
                .attr('fill', 'none')
                .attr('stroke', FUNCTION_COLORS['D'])
                .attr('stroke-width', 35)
                .attr('stroke-opacity', 0.08);

            // Tonica T* ring (para vi/iii)
            zones.append('circle')
                .attr('cx', this.cx)
                .attr('cy', this.cy)
                .attr('r', this.functionRadii['T'])
                .attr('fill', 'none')
                .attr('stroke', FUNCTION_COLORS['T'])
                .attr('stroke-width', 25)
                .attr('stroke-opacity', 0.1);

            // Centro tÃ³nica (I)
            zones.append('circle')
                .attr('cx', this.cx)
                .attr('cy', this.cy)
                .attr('r', 40)
                .attr('fill', FUNCTION_COLORS['T'])
                .attr('fill-opacity', 0.06);

            // Labels
            zones.append('text')
                .attr('x', this.cx)
                .attr('y', this.cy + this.functionRadii['T'] + 35)
                .attr('text-anchor', 'middle')
                .attr('fill', '#64748b')
                .attr('font-size', '10px')
                .text('TÃ“NICA');

            zones.append('text')
                .attr('x', this.cx + this.functionRadii['D'] + 35)
                .attr('y', this.cy + 4)
                .attr('text-anchor', 'start')
                .attr('fill', '#64748b')
                .attr('font-size', '10px')
                .text('DOMINANTE');

            zones.append('text')
                .attr('x', this.cx)
                .attr('y', this.cy - this.functionRadii['S'] - 30)
                .attr('text-anchor', 'middle')
                .attr('fill', '#64748b')
                .attr('font-size', '10px')
                .text('SUBDOMINANTE');
        }

        setActiveChord(chord, tension, gravity = 0.5) {
            const previousChord = this.lastChord;
            this.activeChord = chord;
            this.tension = tension;
            this.lastChord = chord;

            // Update trail
            const node = this.nodes.find(n => n.id === chord);
            if (node) {
                this.trail.push({ x: node.x, y: node.y, chord });
                if (this.trail.length > 8) this.trail.shift();
            }

            // Update visuals (solo el cÃ­rculo visual, no el hit area)
            this.nodeElements.select('.node-visual')
                .attr('fill-opacity', d => d.id === chord ? 0.6 : 0.2)
                .attr('stroke-width', d => d.id === chord ? 4 : 2)
                .attr('filter', d => d.id === chord ? 'url(#glow)' : null);

            // Update narrator
            this.updateNarrator(previousChord, chord, tension, gravity);

            // Draw trail
            this.drawTrail();
        }

        updateNarrator(from, to, tension, gravity) {
            let narrative = '';
            const toFunc = this.getChordData(to)?.function;
            const fromFunc = from ? this.getChordData(from)?.function : null;
            const tonic = this.getTonic();

            // Cadencias especÃ­ficas (mayor y menor)
            if (from === 'V' && (to === 'I' || to === 'i')) {
                narrative = 'âœ“ Cadencia AutÃ©ntica (Reposo total)';
            } else if (from === 'V' && (to === 'vi' || to === 'VI')) {
                narrative = 'â†º Cadencia Deceptiva (Â¡Sorpresa!)';
            } else if ((from === 'IV' || from === 'iv') && (to === 'I' || to === 'i')) {
                narrative = 'âœ“ Cadencia Plagal (AmÃ©n)';
            } else if (from === 'viio' && (to === 'I' || to === 'i')) {
                narrative = 'âœ“ ResoluciÃ³n de sensible';
            }
            // Por tensiÃ³n
            else if (tension > 0.8) {
                narrative = 'âš¡ TensiÃ³n mÃ¡xima, buscando resolver...';
            } else if (tension > 0.6 && toFunc === 'D') {
                narrative = 'â†— Acumulando tensiÃ³n...';
            }
            // Por funciÃ³n
            else if (fromFunc === 'T' && toFunc === 'S') {
                narrative = 'â†’ AlejÃ¡ndose del centro...';
            } else if (fromFunc === 'S' && toFunc === 'D') {
                narrative = 'â†— Preparando la cadencia...';
            } else if (fromFunc === 'D' && toFunc === 'T') {
                narrative = 'â†“ ResoluciÃ³n (llegando a casa)';
            } else if (toFunc === 'T' && tension < 0.2) {
                narrative = 'â— Estabilidad tonal';
            }
            // Por gravedad
            else if (gravity < 0.2) {
                narrative = '~ Deriva libre (sin rumbo)';
            } else if (gravity > 0.8 && toFunc === 'D') {
                narrative = '! Dominante bajo alta gravedad';
            }
            // Default segÃºn funciÃ³n
            else if (toFunc === 'T') {
                narrative = 'â— Zona de reposo';
            } else if (toFunc === 'S') {
                narrative = 'â— Zona de alejamiento';
            } else if (toFunc === 'D') {
                narrative = 'â—‰ Zona de tensiÃ³n';
            }

            // Animar el cambio de texto
            if (this.narratorText) {
                this.narratorText
                    .transition()
                    .duration(150)
                    .attr('opacity', 0)
                    .transition()
                    .duration(150)
                    .attr('opacity', 0.9)
                    .text(narrative);
            }
        }

        drawTrail() {
            this.trailGroup.selectAll('*').remove();

            if (this.trail.length < 2) return;

            const lineGenerator = d3.line()
                .x(d => d.x)
                .y(d => d.y)
                .curve(d3.curveCatmullRom);

            // Trail gradient
            const gradient = d3.select(this.svg).select('defs')
                .selectAll('#trailGradient').data([1]).enter()
                .append('linearGradient')
                .attr('id', 'trailGradient');

            gradient.selectAll('stop').remove();
            this.trail.forEach((point, i) => {
                const chordData = this.getChordData(point.chord);
                const color = FUNCTION_COLORS[chordData?.function || 'T'];
                gradient.append('stop')
                    .attr('offset', `${(i / (this.trail.length - 1)) * 100}%`)
                    .attr('stop-color', color)
                    .attr('stop-opacity', 0.1 + (i / this.trail.length) * 0.5);
            });

            this.trailGroup.append('path')
                .attr('d', lineGenerator(this.trail))
                .attr('class', 'trail-line')
                .attr('stroke', 'url(#trailGradient)')
                .attr('stroke-width', 3);
        }

        showProbabilities(fromChord, modifiedProbs = null) {
            // Usa probabilidades modificadas por gravedad si se pasan, si no las base
            const transitions = this.getTransitions();
            const probs = modifiedProbs || transitions[fromChord];

            this.arcGroup.selectAll('*').remove();

            const fromNode = this.nodes.find(n => n.id === fromChord);

            // Encontrar la probabilidad mÃ¡xima para escalar
            const maxProb = Math.max(...Object.values(probs));

            for (const [toChord, prob] of Object.entries(probs)) {
                if (prob < 0.03) continue;
                const toNode = this.nodes.find(n => n.id === toChord);
                if (!toNode || toChord === fromChord) continue;

                // Normalizar para que la lÃ­nea mÃ¡s probable sea muy visible
                const normalizedProb = prob / maxProb;

                // Grosor: 1-8px segÃºn probabilidad
                const strokeWidth = 1 + normalizedProb * 7;

                // Opacidad: mÃ¡s alta = mÃ¡s visible
                const strokeOpacity = 0.15 + normalizedProb * 0.7;

                // Color mÃ¡s saturado para alta probabilidad
                const chordData = this.getChordData(toChord);
                const baseColor = FUNCTION_COLORS[chordData?.function || 'T'];

                this.arcGroup.append('line')
                    .attr('x1', fromNode.x)
                    .attr('y1', fromNode.y)
                    .attr('x2', toNode.x)
                    .attr('y2', toNode.y)
                    .attr('stroke', baseColor)
                    .attr('stroke-width', strokeWidth)
                    .attr('stroke-opacity', strokeOpacity)
                    .attr('stroke-dasharray', normalizedProb > 0.5 ? 'none' : '4,4');
            }
        }

        hideProbabilities() {
            this.arcGroup.selectAll('*').remove();
        }

        shakeNode(nodeSelection) {
            const shake = () => {
                nodeSelection
                    .transition()
                    .duration(50)
                    .attr('transform', d => {
                        const dx = (Math.random() - 0.5) * this.tension * 6;
                        const dy = (Math.random() - 0.5) * this.tension * 6;
                        return `translate(${d.x + dx}, ${d.y + dy})`;
                    });
            };

            for (let i = 0; i < 5; i++) {
                setTimeout(shake, i * 60);
            }

            setTimeout(() => {
                nodeSelection
                    .transition()
                    .duration(100)
                    .attr('transform', d => `translate(${d.x}, ${d.y})`);
            }, 350);
        }

        triggerResolution() {
            // Burst effect at center
            const particles = d3.select('#particles');
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const particle = particles.append('div')
                    .attr('class', 'resolution-particle')
                    .style('left', `${this.cx}px`)
                    .style('top', `${this.cy}px`)
                    .style('transform', `translate(-50%, -50%) rotate(${angle}rad)`);

                setTimeout(() => particle.remove(), 600);
            }
        }

        resize(width, height) {
            this.width = width;
            this.height = height;
            this.cx = width / 2;
            this.cy = height / 2;

            // Mismos radios que en constructor
            const minDim = Math.min(width, height);
            this.functionRadii = {
                'T': minDim * 0.12,
                'D': minDim * 0.22,
                'S': minDim * 0.34
            };

            this.initPositions();
            this.setupVisualization();
        }
    }

    // ============================================================
    // MAIN APPLICATION
    // ============================================================

    class RameauMachine {
        constructor() {
            this.audioCtx = null;
            this.synth = null;
            this.voiceLeader = new VoiceLeader();
            this.tonalGravity = new TonalGravity();
            this.rhythm = new RhythmicHarmony(80);
            this.bassPatternGen = new BassPatternGenerator();
            this.viz = null;

            this.isPlaying = false;
            this.isGuided = false;
            this.style = 'clasico';
            this.tempo = 80;
            this.key = 'C';
            this.mode = 'major'; // 'major' o 'minor'

            this.nextStepTimeout = null;

            // Recording
            this.isRecording = false;
            this.mediaRecorder = null;
            this.recordedChunks = [];
            this.recordingDestination = null;

            // Voice trail history
            this.voicingHistory = [];
            this.trailCanvas = null;
            this.trailCtx = null;

            // Export history (stores chord + SATB voicing)
            this.exportHistory = [];

            this.init();
        }

        init() {
            // Setup visualization
            const container = document.getElementById('vizContainer');
            const svg = document.getElementById('mainSvg');
            this.viz = new TonalForceField(svg, container.clientWidth, container.clientHeight);

            // Click handler for guided mode
            this.viz.onChordClick = (chord) => {
                if (this.isGuided) {
                    this.playChord(chord, true);
                }
            };

            // Bind controls
            this.bindControls();

            // Resize handler
            window.addEventListener('resize', () => {
                const container = document.getElementById('vizContainer');
                this.viz.resize(container.clientWidth, container.clientHeight);
            });

            // Initialize voice trail canvas
            this.trailCanvas = document.getElementById('voiceTrail');
            this.trailCtx = this.trailCanvas.getContext('2d');
            this.resizeTrailCanvas();

            // Initial display
            this.updateDisplay();
            this.updateBassViz();
            this.updateProbabilities();
            this.updateMatrix();
            this.updateEntropy();
            this.updateChaosLevel();
        }

        resizeTrailCanvas() {
            const container = this.trailCanvas.parentElement;
            this.trailCanvas.width = container.clientWidth - 20;
            this.trailCanvas.height = 80;
        }

        initAudio() {
            if (!this.audioCtx) {
                this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                this.synth = new VoiceLeadingSynth(this.audioCtx);
                this.synth.applyStyle(this.style);

                // Sync mute/volume state from UI
                for (let i = 0; i < 4; i++) {
                    const fader = document.getElementById(`fader-${i}`);
                    const muteBtn = document.getElementById(`mute-${i}`);
                    this.synth.setVoiceVolume(i, parseInt(fader.value) / 100);
                    this.synth.setMute(i, muteBtn.classList.contains('muted'));
                }
            }
            if (this.audioCtx.state === 'suspended') {
                this.audioCtx.resume();
            }
        }

        bindControls() {
            // Play/Pause
            document.getElementById('playBtn').addEventListener('click', () => {
                this.togglePlay();
            });

            // Reset
            document.getElementById('resetBtn').addEventListener('click', () => {
                this.reset();
            });

            // Tempo
            const tempoSlider = document.getElementById('tempoSlider');
            tempoSlider.addEventListener('input', (e) => {
                this.tempo = parseInt(e.target.value);
                this.rhythm.setTempo(this.tempo);
                document.getElementById('tempoValue').textContent = `${this.tempo} BPM`;
                document.getElementById('tempoFill').style.width = `${((this.tempo - 40) / 100) * 100}%`;
            });

            // Key selector
            document.querySelectorAll('#keySelector button').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('#keySelector button').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    this.key = btn.dataset.key;
                    this.tonalGravity.setKey(this.key);

                    // Resetear contador de modulaciÃ³n al cambiar manualmente
                    this.tonalGravity.chordsSinceModulation = 0;

                    // Ocultar badge de modulaciÃ³n
                    const badge = document.getElementById('modulationBadge');
                    if (badge) badge.style.display = 'none';

                    // Actualizar display de tonalidad actual
                    const keyDisplay = document.getElementById('currentKeyDisplay');
                    if (keyDisplay) keyDisplay.textContent = this.key;
                });
            });

            // Mode toggle (Mayor/Menor)
            document.getElementById('modeToggle').addEventListener('change', (e) => {
                this.mode = e.target.checked ? 'minor' : 'major';
                document.getElementById('modeLabel').textContent = e.target.checked ? 'Menor' : 'Mayor';
                document.getElementById('modeLabel').className = e.target.checked
                    ? 'text-xs text-blue-400'
                    : 'text-xs text-green-400';

                // Actualizar TonalGravity
                this.tonalGravity.setMode(this.mode);

                // Redibujar visualizaciÃ³n con nuevos acordes
                this.viz.setMode(this.mode);

                // Resetear al acorde tÃ³nica del nuevo modo
                const tonic = this.mode === 'minor' ? 'i' : 'I';
                this.viz.setActiveChord(tonic, 0, this.tonalGravity.getGravity());

                // Actualizar matriz y displays
                this.updateMatrix();
                this.updateProbabilities();
            });

            // ModulaciÃ³n automÃ¡tica toggle
            document.getElementById('modulationToggle').addEventListener('change', (e) => {
                this.tonalGravity.setModulationEnabled(e.target.checked);
                console.log('ModulaciÃ³n automÃ¡tica:', e.target.checked ? 'ON' : 'OFF');
            });

            // BotÃ³n modulaciÃ³n manual
            document.getElementById('modulateBtn').addEventListener('click', () => {
                const event = this.tonalGravity.forceModulation();
                if (event) {
                    this.handleModulationEvent(event);
                    // Si estÃ¡ sonando, tocar el nuevo I
                    if (this.isPlaying) {
                        this.playChord(this.tonalGravity.position, false);
                    }
                }
            });

            // Style
            document.querySelectorAll('input[name="style"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    this.style = e.target.value;
                    this.rhythm.setStyle(this.style);
                    this.voiceLeader.setStyle(this.style);
                    if (this.synth) {
                        this.synth.applyStyle(this.style);
                    }
                });
            });

            // Mode buttons
            document.getElementById('modeAuto').addEventListener('click', () => {
                this.isGuided = false;
                document.getElementById('modeAuto').classList.replace('bg-slate-700', 'bg-blue-600');
                document.getElementById('modeGuided').classList.replace('bg-blue-600', 'bg-slate-700');
            });

            document.getElementById('modeGuided').addEventListener('click', () => {
                this.isGuided = true;
                document.getElementById('modeGuided').classList.replace('bg-slate-700', 'bg-blue-600');
                document.getElementById('modeAuto').classList.replace('bg-blue-600', 'bg-slate-700');
            });

            // Help modal
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').classList.remove('hidden');
            });

            document.getElementById('closeHelp').addEventListener('click', () => {
                document.getElementById('helpModal').classList.add('hidden');
            });

            document.getElementById('helpModal').addEventListener('click', (e) => {
                if (e.target === document.getElementById('helpModal')) {
                    document.getElementById('helpModal').classList.add('hidden');
                }
            });

            // Record button
            document.getElementById('recordBtn').addEventListener('click', () => {
                this.toggleRecording();
            });

            // Export button (text)
            document.getElementById('exportBtn').addEventListener('click', () => {
                this.exportProgression();
            });

            // Export MusicXML button
            document.getElementById('exportXMLBtn').addEventListener('click', () => {
                this.exportMusicXML();
            });

            // Gravity slider
            const gravitySlider = document.getElementById('gravitySlider');
            gravitySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                this.tonalGravity.setGravity(value / 100);
                document.getElementById('gravityValue').textContent = `${value}%`;
                document.getElementById('gravityFill').style.width = `${value}%`;
                // Actualizar visualizaciÃ³n en tiempo real
                this.updateProbabilities();
                this.updateMatrix();
                this.updateEntropy();
            });

            // Chaos button
            document.getElementById('chaosBtn').addEventListener('click', () => {
                this.tonalGravity.injectChaos(0.5);
                const btn = document.getElementById('chaosBtn');
                btn.classList.add('active');
                setTimeout(() => btn.classList.remove('active'), 300);
                // Actualizar visualizaciÃ³n
                this.updateProbabilities();
                this.updateMatrix();
                this.updateEntropy();
                this.updateChaosLevel();
            });

            // Matrix toggle
            document.getElementById('matrixHeader').addEventListener('click', () => {
                const matrix = document.getElementById('matrixDisplay');
                const chevron = document.getElementById('matrixChevron');
                matrix.classList.toggle('collapsed');
                chevron.classList.toggle('matrix-chevron-rotated');
            });

            // Voice Mixer Controls
            for (let i = 0; i < 4; i++) {
                // Faders
                const fader = document.getElementById(`fader-${i}`);
                const faderFill = document.getElementById(`faderFill-${i}`);
                fader.addEventListener('input', (e) => {
                    const value = parseInt(e.target.value);
                    faderFill.style.height = `${value}%`;
                    if (this.synth) {
                        this.synth.setVoiceVolume(i, value / 100);
                    }
                });

                // Mute buttons
                const muteBtn = document.getElementById(`mute-${i}`);
                muteBtn.addEventListener('click', () => {
                    if (this.synth) {
                        const muted = this.synth.toggleMute(i);
                        muteBtn.classList.toggle('muted', muted);
                    } else {
                        // Toggle visual even without synth
                        muteBtn.classList.toggle('muted');
                    }
                });
            }

            // Audio Knob Controls
            this.setupKnob('knobMaster', 'masterValue', (value) => {
                if (this.synth) this.synth.setMasterVolume(value);
            });

            this.setupKnob('knobReverb', 'reverbValue', (value) => {
                if (this.synth) this.synth.setReverbMix(value / 100);
            });

            this.setupKnob('knobFilter', 'filterValue', (value) => {
                if (this.synth) this.synth.setFilterBrightness(value);
            });

            this.setupKnob('knobDetune', 'detuneValue', (value) => {
                if (this.synth) this.synth.setDetuneAmount(value);
            });

            this.setupKnob('knobVibrato', 'vibratoValue', (value) => {
                if (this.synth) this.synth.setVibratoDepth(value);
            });

            this.setupKnob('knobAttack', 'attackValue', (value) => {
                if (this.synth) this.synth.setAttack(value);
            });

            this.setupKnob('knobRelease', 'releaseValue', (value) => {
                if (this.synth) this.synth.setRelease(value);
            });
        }

        setupKnob(knobId, valueId, callback) {
            const knob = document.getElementById(knobId);
            const valueDisplay = document.getElementById(valueId);
            if (!knob) return;

            let isDragging = false;
            let startY = 0;
            let startValue = parseInt(knob.dataset.value) || 50;

            const updateKnob = (value) => {
                value = Math.max(0, Math.min(100, value));
                knob.dataset.value = value;
                // Rotation: -135deg (0%) to +135deg (100%)
                const rotation = -135 + (value / 100) * 270;
                knob.style.setProperty('--rotation', `${rotation}deg`);
                if (valueDisplay) valueDisplay.textContent = `${Math.round(value)}%`;
                callback(value);
            };

            knob.addEventListener('mousedown', (e) => {
                isDragging = true;
                startY = e.clientY;
                startValue = parseInt(knob.dataset.value) || 50;
                knob.classList.add('active');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const deltaY = startY - e.clientY;
                const newValue = startValue + deltaY * 0.5;
                updateKnob(newValue);
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    knob.classList.remove('active');
                }
            });

            // Double click to reset
            knob.addEventListener('dblclick', () => {
                updateKnob(50);
            });

            // Initialize
            updateKnob(startValue);
        }

        togglePlay() {
            if (this.isPlaying) {
                this.stop();
            } else {
                this.play();
            }
        }

        play() {
            this.initAudio();
            this.isPlaying = true;

            const playBtn = document.getElementById('playBtn');
            playBtn.classList.replace('play', 'pause');
            document.getElementById('playIcon').innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';

            if (!this.isGuided) {
                this.scheduleNextStep();
            } else {
                // Play current chord once
                this.playChord(this.tonalGravity.position, false);
            }
        }

        stop() {
            this.isPlaying = false;

            const playBtn = document.getElementById('playBtn');
            playBtn.classList.replace('pause', 'play');
            document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z"/>';

            if (this.nextStepTimeout) {
                clearTimeout(this.nextStepTimeout);
                this.nextStepTimeout = null;
            }

            if (this.synth) {
                this.synth.stop();
            }
        }

        reset() {
            this.stop();
            this.tonalGravity.reset();
            this.voiceLeader.voices = [48, 52, 55, 60];
            this.viz.trail = [];
            this.viz.setActiveChord('I', 0, this.tonalGravity.gravity);
            this.updateDisplay();
            this.updateBassViz();
            this.updateProbabilities();
            this.updateMatrix();
            this.updateEntropy();
            this.updateChaosLevel();
        }

        scheduleNextStep() {
            if (!this.isPlaying || this.isGuided) return;

            const result = this.tonalGravity.step();
            this.playChord(result.chord, false);

            // Verificar modulaciÃ³n despuÃ©s de cada acorde
            const modulationEvent = this.tonalGravity.checkModulation();
            if (modulationEvent) {
                this.handleModulationEvent(modulationEvent);
            }

            const chordsDict = this.tonalGravity.getChords();
            const context = {
                tensionLevel: result.tension,
                isResolution: chordsDict[result.chord]?.function === 'T' && result.tension < 0.3
            };

            const duration = this.rhythm.computeDuration(result.chord, context);

            this.nextStepTimeout = setTimeout(() => {
                this.scheduleNextStep();
            }, duration * 1000);
        }

        handleModulationEvent(event) {
            try {
                const keyDisplay = document.getElementById('currentKeyDisplay');
                const modulationBadge = document.getElementById('modulationBadge');

                // ModulaciÃ³n completada - actualizar UI
                if (keyDisplay) {
                    keyDisplay.textContent = event.to;
                    keyDisplay.classList.add('key-changed');
                    setTimeout(() => keyDisplay.classList.remove('key-changed'), 500);
                }
                if (modulationBadge) {
                    modulationBadge.textContent = `${event.from} â†’ ${event.to}`;
                    modulationBadge.className = 'modulation-badge complete';
                    modulationBadge.style.display = 'inline-block';
                    setTimeout(() => {
                        modulationBadge.style.display = 'none';
                    }, 2500);
                }

                // Actualizar botÃ³n de tonalidad activo
                this.updateKeyButtons(event.to);
                this.key = event.to;

                // Actualizar el synth con la nueva tonalidad
                if (this.synth) {
                    this.synth.setKey(this.tonalGravity.keyPitch);
                }

                console.log(`Â¡ModulaciÃ³n! ${event.from} â†’ ${event.to} (${event.relation})`);
            } catch (err) {
                console.error('Error en modulaciÃ³n:', err);
            }
        }

        updateKeyButtons(newKey) {
            document.querySelectorAll('.key-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.key === newKey);
            });
        }

        playChord(chord, isManual) {
            this.initAudio();

            let result;
            if (isManual) {
                result = this.tonalGravity.goTo(chord);
            } else {
                result = {
                    chord,
                    inversion: this.tonalGravity.inversion,
                    tension: this.tonalGravity.tension,
                    bass: this.tonalGravity.bassHistory[this.tonalGravity.bassHistory.length - 1]
                };
            }

            // Voice leading
            const voiceResult = this.voiceLeader.transition(chord, result.inversion, this.tonalGravity.keyPitch);

            // Get correct chord dictionary for current mode
            const currentChords = this.tonalGravity.getChords();

            // Compute articulation and duration
            const context = {
                tensionLevel: result.tension,
                isResolution: currentChords[chord]?.function === 'T' && result.tension < 0.3
            };

            const articulation = this.rhythm.computeArticulation(chord, context);
            const duration = this.rhythm.computeDuration(chord, context);

            // Generar patrÃ³n de bajo segÃºn estilo
            let bassPattern = null;
            if (voiceResult) {
                const chordData = currentChords[chord];
                const keyPitch = this.tonalGravity.keyPitch;

                // Obtener las notas del acorde transpuestas
                const bassNote = voiceResult.to[0]; // Nota MIDI del bajo
                const bassPitchClass = bassNote % 12;

                // Calcular tercera y quinta relativas al bajo actual
                const thirdPC = (chordData.third + keyPitch) % 12;
                const fifthPC = (chordData.fifth + keyPitch) % 12;

                // Encontrar tercera y quinta en el registro del bajo
                const bassOctave = Math.floor(bassNote / 12);
                let third = thirdPC + (bassOctave * 12);
                let fifth = fifthPC + (bassOctave * 12);

                // Asegurar que estÃ¡n por encima del bajo
                if (third <= bassNote) third += 12;
                if (fifth <= bassNote) fifth += 12;

                // Generar patrÃ³n
                bassPattern = this.bassPatternGen.generate(
                    this.style,
                    [bassNote, third, fifth]
                );
            }

            // Play audio
            if (voiceResult) {
                this.synth.transitionTo(voiceResult.to, duration, articulation, bassPattern);

                // Store for MusicXML export
                this.exportHistory.push({
                    chord: chord,
                    voices: [...voiceResult.to], // [bass, tenor, alto, soprano]
                    key: this.key,
                    mode: this.mode,
                    duration: duration
                });
            }

            // Update visualization
            this.viz.setActiveChord(chord, result.tension, this.tonalGravity.gravity);

            const chordsDict = this.tonalGravity.getChords();
            if (chordsDict[chord]?.function === 'T' && result.tension < 0.3) {
                this.viz.triggerResolution();
            }

            // Update UI
            this.updateDisplay();
            this.updateTension(result.tension);
            this.updateVoiceDisplay(voiceResult?.to || this.voiceLeader.getVoices());
            this.updateBassViz();
            this.updateProbabilities();
            this.updateMatrix();
            this.updateEntropy();
            this.updateChaosLevel();

            // Check cadence
            const cadence = this.tonalGravity.detectCadence();
            this.updateCadenceDisplay(cadence);
        }

        updateDisplay() {
            // Progression
            const history = this.tonalGravity.history.slice(-8);
            document.getElementById('progressionDisplay').textContent = history.join(' - ');

            // Bass note
            const bassPC = this.tonalGravity.bassHistory[this.tonalGravity.bassHistory.length - 1];
            const bassNote = NOTE_NAMES[(bassPC + this.tonalGravity.keyPitch) % 12];
            document.getElementById('bassDisplay').textContent = bassNote;
        }

        updateTension(tension) {
            const fill = document.getElementById('tensionFill');
            fill.style.width = `${tension * 100}%`;

            // Color based on tension
            if (tension < 0.3) {
                fill.style.background = '#22c55e';
            } else if (tension < 0.6) {
                fill.style.background = '#eab308';
            } else {
                fill.style.background = '#ef4444';
            }

            document.getElementById('tensionValue').textContent = tension.toFixed(2);
        }

        updateVoiceDisplay(voices) {
            const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

            voices.forEach((note, i) => {
                // Update note display
                const noteName = noteNames[note % 12];
                const octave = Math.floor(note / 12) - 1;
                document.getElementById(`note-${i}`).textContent = `${noteName}${octave}`;

                // Flash LED
                const led = document.getElementById(`led-${i}`);
                led.classList.add('active');
                setTimeout(() => led.classList.remove('active'), 200);
            });

            // Add to history for trail visualization
            this.voicingHistory.push([...voices]);
            if (this.voicingHistory.length > 12) {
                this.voicingHistory.shift();
            }

            // Update trail
            this.updateVoiceTrail();
        }

        updateVoiceTrail() {
            const ctx = this.trailCtx;
            const canvas = this.trailCanvas;
            const w = canvas.width;
            const h = canvas.height;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);

            if (this.voicingHistory.length < 2) return;

            const voiceColors = ['#f97316', '#22c55e', '#3b82f6', '#a855f7']; // B, T, A, S
            const voiceNames = ['bass', 'tenor', 'alto', 'soprano'];
            const stepWidth = w / 11; // 12 puntos, 11 espacios

            // Draw each voice line
            for (let v = 0; v < 4; v++) {
                const range = this.voiceLeader.voiceRanges[voiceNames[v]];
                const color = voiceColors[v];

                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();

                this.voicingHistory.forEach((voicing, i) => {
                    const note = voicing[v];
                    const normalized = (note - range.min) / (range.max - range.min);
                    const x = i * stepWidth + stepWidth / 2;
                    const y = h - (normalized * (h - 16) + 8); // Padding 8px top/bottom

                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();

                // Draw dots
                ctx.fillStyle = color;
                this.voicingHistory.forEach((voicing, i) => {
                    const note = voicing[v];
                    const normalized = (note - range.min) / (range.max - range.min);
                    const x = i * stepWidth + stepWidth / 2;
                    const y = h - (normalized * (h - 16) + 8);

                    const radius = i === this.voicingHistory.length - 1 ? 5 : 3;
                    const alpha = 0.4 + (i / this.voicingHistory.length) * 0.6;

                    ctx.globalAlpha = alpha;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                });

                ctx.globalAlpha = 1;
            }
        }

        updateCadenceDisplay(cadence) {
            const display = document.getElementById('cadenceDisplay');
            if (cadence) {
                display.innerHTML = `<span class="cadence-badge ${cadence.class}">${cadence.label}</span>`;
            } else {
                display.textContent = '-';
            }
        }

        updateBassViz() {
            const viz = document.getElementById('bassViz');
            viz.innerHTML = '';

            const bassHistory = this.tonalGravity.bassHistory.slice(-12);
            bassHistory.forEach((bass, i) => {
                const bar = document.createElement('div');
                bar.className = 'bass-bar';
                const height = 20 + (((bass % 12) + 12) % 12) * 1.5;
                bar.style.height = `${height}px`;
                bar.style.opacity = 0.3 + (i / bassHistory.length) * 0.7;
                viz.appendChild(bar);
            });
        }

        updateProbabilities() {
            const currentChord = this.tonalGravity.position;
            const probs = this.tonalGravity.getTransitionProbabilities();

            // Update label
            document.getElementById('currentChordLabel').textContent = currentChord;

            // Actualizar visualizaciÃ³n con lÃ­neas proporcionales a probabilidad
            this.viz.showProbabilities(currentChord, probs);

            // Sort by probability descending
            const sorted = Object.entries(probs).sort((a, b) => b[1] - a[1]);

            const container = document.getElementById('probDisplay');
            container.innerHTML = '';

            const chordsDict = this.tonalGravity.getChords();
            sorted.forEach(([chord, prob]) => {
                const func = chordsDict[chord]?.function || 'T';
                const percent = (prob * 100).toFixed(0);

                const row = document.createElement('div');
                row.className = 'prob-row';
                row.innerHTML = `
                    <span class="prob-label">${chord}</span>
                    <div class="prob-bar-container">
                        <div class="prob-bar func-${func}" style="width: ${percent}%"></div>
                    </div>
                    <span class="prob-value">${percent}%</span>
                `;
                container.appendChild(row);
            });
        }

        updateMatrix() {
            const container = document.getElementById('matrixDisplay');
            const currentChord = this.tonalGravity.position;
            const chordsDict = this.tonalGravity.getChords();
            const chordOrder = this.mode === 'minor'
                ? ['i', 'iio', 'III', 'iv', 'V', 'VI', 'viio']
                : ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'viio'];

            // Crear grid
            let html = '<div class="matrix-grid">';

            // Header row
            html += '<div class="matrix-header"></div>'; // Esquina vacÃ­a
            for (const chord of chordOrder) {
                const func = chordsDict[chord]?.function || 'T';
                html += `<div class="matrix-header" style="color: ${FUNCTION_COLORS[func]}">${chord}</div>`;
            }

            // Data rows
            for (const fromChord of chordOrder) {
                const fromFunc = chordsDict[fromChord]?.function || 'T';
                const isCurrentRow = fromChord === currentChord;

                // Row label
                html += `<div class="matrix-row-label" style="color: ${FUNCTION_COLORS[fromFunc]}">${fromChord}</div>`;

                // Temporarily set position to get probabilities for this row
                const originalPos = this.tonalGravity.position;
                this.tonalGravity.position = fromChord;
                const probs = this.tonalGravity.getTransitionProbabilities();
                this.tonalGravity.position = originalPos;

                for (const toChord of chordOrder) {
                    const prob = probs[toChord] || 0;
                    const toFunc = chordsDict[toChord]?.function || 'T';

                    // Color intensity based on probability
                    const intensity = Math.min(1, prob * 2);
                    const bgColor = this.probToColor(prob, toFunc);

                    const cellClass = isCurrentRow ? 'matrix-cell current-row' : 'matrix-cell';
                    const displayProb = prob >= 0.1 ? Math.round(prob * 100) : '';

                    html += `<div class="${cellClass}" style="background: ${bgColor}" title="${fromChord}â†’${toChord}: ${(prob*100).toFixed(1)}%">${displayProb}</div>`;
                }
            }

            html += '</div>';
            container.innerHTML = html;
        }

        probToColor(prob, func) {
            // Devuelve color RGBA basado en probabilidad y funciÃ³n
            const colors = {
                'T': [34, 197, 94],   // Verde
                'S': [59, 130, 246],  // Azul
                'D': [239, 68, 68]    // Rojo
            };
            const rgb = colors[func] || [148, 163, 184];
            const alpha = Math.min(0.9, prob * 1.5);
            return `rgba(${rgb[0]}, ${rgb[1]}, ${rgb[2]}, ${alpha})`;
        }

        updateEntropy() {
            const entropy = this.tonalGravity.getEntropy();
            document.getElementById('entropyValue').textContent = entropy.toFixed(2);
            document.getElementById('entropyFill').style.width = `${entropy * 100}%`;
        }

        updateChaosLevel() {
            const chaos = this.tonalGravity.chaosNoise;
            document.getElementById('chaosLevel').textContent = `${Math.round(chaos * 100)}%`;
        }

        // ========== RECORDING ==========
        toggleRecording() {
            if (this.isRecording) {
                this.stopRecording();
            } else {
                this.startRecording();
            }
        }

        startRecording() {
            this.initAudio();

            // Create a destination for recording
            this.recordingDestination = this.audioCtx.createMediaStreamDestination();
            this.synth.masterGain.connect(this.recordingDestination);

            this.recordedChunks = [];
            this.mediaRecorder = new MediaRecorder(this.recordingDestination.stream, {
                mimeType: 'audio/webm'
            });

            this.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    this.recordedChunks.push(e.data);
                }
            };

            this.mediaRecorder.onstop = () => {
                const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rameau-${this.key}-${Date.now()}.webm`;
                a.click();
                URL.revokeObjectURL(url);

                // Disconnect recording destination
                this.synth.masterGain.disconnect(this.recordingDestination);
            };

            this.mediaRecorder.start();
            this.isRecording = true;

            // Update UI
            const btn = document.getElementById('recordBtn');
            btn.classList.replace('bg-slate-700', 'bg-red-600');
            btn.classList.add('animate-pulse');
        }

        stopRecording() {
            if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {
                this.mediaRecorder.stop();
            }
            this.isRecording = false;

            // Update UI
            const btn = document.getElementById('recordBtn');
            btn.classList.replace('bg-red-600', 'bg-slate-700');
            btn.classList.remove('animate-pulse');
        }

        // ========== EXPORT ==========
        exportProgression() {
            const history = this.tonalGravity.history;
            const key = this.key;
            const style = this.style;
            const tempo = this.tempo;

            // Build text output
            let output = `# Rameau Machine - Progresion Exportada\n\n`;
            const modeName = this.mode === 'minor' ? 'menor' : 'Mayor';
            output += `Tonalidad: ${key} ${modeName}\n`;
            output += `Estilo: ${style.charAt(0).toUpperCase() + style.slice(1)}\n`;
            output += `Tempo: ${tempo} BPM\n\n`;
            output += `## Progresion\n\n`;
            output += history.join(' - ') + '\n\n';

            // Analisis funcional
            const chordsDict = this.tonalGravity.getChords();
            output += `## Analisis Funcional\n\n`;
            history.forEach((chord, i) => {
                const func = chordsDict[chord]?.function || 'T';
                const funcName = func === 'T' ? 'Tonica' : func === 'S' ? 'Subdominante' : 'Dominante';
                output += `${i + 1}. ${chord} (${funcName})\n`;
            });

            // Cadencias detectadas
            output += `\n## Cadencias\n\n`;
            for (let i = 1; i < history.length; i++) {
                const pair = [history[i-1], history[i]];
                for (const [name, cadence] of Object.entries(CADENCES)) {
                    const [p1, p2] = cadence.pattern;
                    if ((p1 === '*' || p1 === pair[0]) && p2 === pair[1]) {
                        output += `- Compas ${i}: ${cadence.label} (${pair[0]} -> ${pair[1]})\n`;
                    }
                }
            }

            output += `\n---\nGenerado por Rameau Machine\n`;

            // Download
            const blob = new Blob([output], { type: 'text/markdown' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rameau-progresion-${key}-${Date.now()}.md`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ========== MUSICXML EXPORT ==========
        exportMusicXML() {
            if (this.exportHistory.length === 0) {
                alert('No hay acordes para exportar. Reproduce algunos acordes primero.');
                return;
            }

            const xml = this.generateMusicXML();
            const blob = new Blob([xml], { type: 'application/vnd.recordare.musicxml+xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `rameau-${this.key}-${this.mode}-${Date.now()}.musicxml`;
            a.click();
            URL.revokeObjectURL(url);
        }

        generateMusicXML() {
            const history = this.exportHistory;
            const divisions = 1; // 1 division per quarter note
            const beats = 4;
            const beatType = 4;

            // Helper: MIDI to MusicXML pitch
            const midiToPitch = (midi) => {
                const noteNames = ['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B'];
                const alterations = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
                const pc = midi % 12;
                const octave = Math.floor(midi / 12) - 1;
                return {
                    step: noteNames[pc],
                    alter: alterations[pc],
                    octave: octave
                };
            };

            // Helper: Get chord root and kind for harmony element
            const getChordHarmony = (chordName, keyPitch) => {
                const chordsDict = this.tonalGravity.getChords();
                const chord = chordsDict[chordName];
                if (!chord) return null;

                const rootPC = (chord.root + keyPitch) % 12;

                // Use flats for flat keys, sharps for sharp keys
                const keyFifths = this.getKeyFifths();
                const useFlats = keyFifths < 0;

                // Sharp names: C, C#, D, D#, E, F, F#, G, G#, A, A#, B
                // Flat names:  C, Db, D, Eb, E, F, Gb, G, Ab, A, Bb, B
                const sharpNames = ['C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B'];
                const sharpAlters = [0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0];
                const flatNames = ['C', 'D', 'D', 'E', 'E', 'F', 'G', 'G', 'A', 'A', 'B', 'B'];
                const flatAlters = [0, -1, 0, -1, 0, 0, -1, 0, -1, 0, -1, 0];

                const rootNames = useFlats ? flatNames : sharpNames;
                const rootAlters = useFlats ? flatAlters : sharpAlters;

                // MusicXML kind values
                let kind = 'major';
                let kindText = ''; // Additional text for display
                if (chord.quality === 'minor') {
                    kind = 'minor';
                    kindText = 'm';
                } else if (chord.quality === 'dim') {
                    kind = 'diminished';
                    kindText = 'dim';
                } else if (chord.quality === 'dom7') {
                    kind = 'dominant';
                    kindText = '7';
                }

                return {
                    root: rootNames[rootPC],
                    alter: rootAlters[rootPC],
                    kind: kind,
                    kindText: kindText,
                    symbol: chordName // Roman numeral
                };
            };

            // Voice names and clefs
            const voices = [
                { id: 'P1', name: 'Soprano', abbr: 'S', clef: { sign: 'G', line: 2 } },
                { id: 'P2', name: 'Alto', abbr: 'A', clef: { sign: 'G', line: 2 } },
                { id: 'P3', name: 'Tenor', abbr: 'T', clef: { sign: 'G', line: 2, octaveChange: -1 } },
                { id: 'P4', name: 'Bajo', abbr: 'B', clef: { sign: 'F', line: 4 } }
            ];

            // Map export history voices: [bass, tenor, alto, soprano] -> we need [soprano, alto, tenor, bass]
            const voiceIndices = [3, 2, 1, 0]; // soprano=3, alto=2, tenor=1, bass=0

            let xml = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.1 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.1">
  <work>
    <work-title>Rameau Machine - ${this.key} ${this.mode === 'minor' ? 'menor' : 'Mayor'}</work-title>
  </work>
  <identification>
    <creator type="composer">Rameau Machine</creator>
    <encoding>
      <software>Rameau Machine - Armonia Funcional Generativa</software>
      <encoding-date>${new Date().toISOString().split('T')[0]}</encoding-date>
    </encoding>
  </identification>
  <part-list>
`;

            // Part list
            voices.forEach(v => {
                xml += `    <score-part id="${v.id}">
      <part-name>${v.name}</part-name>
      <part-abbreviation>${v.abbr}</part-abbreviation>
    </score-part>
`;
            });

            xml += `  </part-list>
`;

            // Generate parts
            voices.forEach((voice, vIdx) => {
                const sourceIdx = voiceIndices[vIdx];
                xml += `  <part id="${voice.id}">
`;

                history.forEach((entry, mIdx) => {
                    const midi = entry.voices[sourceIdx];
                    const pitch = midiToPitch(midi);
                    const isFirstMeasure = mIdx === 0;

                    xml += `    <measure number="${mIdx + 1}">
`;

                    // Attributes only in first measure
                    if (isFirstMeasure) {
                        xml += `      <attributes>
        <divisions>${divisions}</divisions>
        <key>
          <fifths>${this.getKeyFifths()}</fifths>
          <mode>${this.mode === 'minor' ? 'minor' : 'major'}</mode>
        </key>
        <time>
          <beats>${beats}</beats>
          <beat-type>${beatType}</beat-type>
        </time>
        <clef>
          <sign>${voice.clef.sign}</sign>
          <line>${voice.clef.line}</line>
${voice.clef.octaveChange ? `          <clef-octave-change>${voice.clef.octaveChange}</clef-octave-change>\n` : ''}        </clef>
      </attributes>
`;
                    }

                    // Add chord symbol (harmony) to Soprano part only
                    if (vIdx === 0) {
                        const harmony = getChordHarmony(entry.chord, this.tonalGravity.keyPitch);
                        if (harmony) {
                            // Build chord name with alteration
                            const alterText = harmony.alter === 1 ? 'â™¯' : (harmony.alter === -1 ? 'â™­' : '');
                            const chordDisplay = `${harmony.root}${alterText}${harmony.kindText}`;

                            xml += `      <harmony print-frame="no">
        <root>
          <root-step>${harmony.root}</root-step>
${harmony.alter !== 0 ? `          <root-alter>${harmony.alter}</root-alter>\n` : ''}        </root>
        <kind text="${harmony.kindText}">${harmony.kind}</kind>
      </harmony>
      <direction placement="above">
        <direction-type>
          <words default-y="40" font-size="10" font-style="italic">${harmony.symbol}</words>
        </direction-type>
      </direction>
`;
                        }
                    }

                    // Note (whole note = 4 beats)
                    xml += `      <note>
        <pitch>
          <step>${pitch.step}</step>
${pitch.alter !== 0 ? `          <alter>${pitch.alter}</alter>\n` : ''}          <octave>${pitch.octave}</octave>
        </pitch>
        <duration>${divisions * 4}</duration>
        <type>whole</type>
      </note>
`;

                    xml += `    </measure>
`;
                });

                xml += `  </part>
`;
            });

            xml += `</score-partwise>`;

            return xml;
        }

        getKeyFifths() {
            // Circle of fifths position for MusicXML
            const keyFifths = {
                'C': 0, 'G': 1, 'D': 2, 'A': 3, 'E': 4, 'B': 5, 'F#': 6, 'Gb': -6,
                'F': -1, 'Bb': -2, 'Eb': -3, 'Ab': -4, 'Db': -5, 'Cb': -7,
                'C#': 7
            };
            return keyFifths[this.key] || 0;
        }

        clearExportHistory() {
            this.exportHistory = [];
        }
    }

    // Initialize on load
    document.addEventListener('DOMContentLoaded', () => {
        window.rameauMachine = new RameauMachine();
    });
    </script>
</body>
</html>
